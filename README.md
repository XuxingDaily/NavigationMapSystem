# 小谷围岛导航地图系统
  
##一、数据种类？如何获取？
  
- **各类POI**：高德API爬取；
- **公交站点和公交线路**：网络爬虫。首先获取8684公交网站上的公交线路名称，然后用爬取好的线路名称，通过高德api批量爬取线要素，最后利用pandas对爬取的公交线路数据进行数据处理，保存后入库；
- **路网数据**：从OSM平台下载和导入数据到GIS平台软件，经过人工清洗，识别并处理拓扑错误，统一和标准化属性，道路打断处理，后导入MySQL数据库。
  
## 二、系统设计

- **前端**：使用传统的HTML、CSS、JavaScript（Typescript）进行前端开发。GIS渲染采用了独立开发的GIS可视化库，可支持矢量渲染，并使用webpack打包工具进行打包压缩；
- **后端**：使用node.js的Express库进行开发，并遵循了类似MVC的模式，通过分离关注点（数据管理、用户界面展示、和请求处理逻辑），使得代码更加模块化，易于理解和维护。；
- **数据库**：使用MySQL数据库存储路网数据、POI数据和公交数据；

选用HTML、CSS、Typescript作为前端开发，考虑如下：

- **广泛的支持与社区资源**：HTML、CSS是构建Web的基础，拥有广泛的支持和大量的开发资源。TypeScript作为JavaScript的超集，提供了类型检查和更高的代码质量保证，有助于避免一些常见的编程错误，特别是在团队合作中。
- **前后端分离的开发模式**：TypeScript配合HTML和CSS可以构建出响应式且交互性强的前端应用，而MySQL作为后端数据库，可以有效地存储和管理数据。这种前后端分离的架构不仅使得开发更为高效，还有利于后期的维护和扩展。MySQL作为一个成熟的关系数据库管理系统，为数据存储提供了稳定和高效的支持。

## 三、数据库如何设计？

- 对于自驾线路导航，我采用了**节点与边分离的图结构表示方法**，使用三个表分别表示起点、终点和边。
  - 在自驾线路导航中，我使用了Dijkstra算法。Dijkstra算法在这种模型中非常适用，因为它需要访问节点之间的连接信息（即边的信息），以及边的权重来计算最短路径。该模型的结构使得算法能够轻松地遍历图中的边，并使用边的权重信息来更新路径长度。
- 对于公交线路导航，我采用了**以边为记录的图结构表示方法**，使用一个表存有边的所有信息，例如线段ID、起点、终点以及距离等。
  - 在公交车线路规划中，我们使用了BFS算法，其中引入了路线名进行计算，优先考虑与上一条边同名的邻边，得到最终结果。
- 同时POI入库，包含POI名称、坐标信息等。


## 四、算法如何选择？

根据需求进行衡量。

- **自驾导航系统**一个关键需求是计算从起点到终点的最短或最快路径，其中“最短”或“最快”可以根据道路长度、预计旅行时间、交通状况等多种因素来衡量。Dijkstra 算法适用于处理带有正权重的图，能够有效地找到最短路径。在本案例中使用“距离”作为成本。
- **公交线路导航**面临的挑战与自驾导航不同。用户通常希望找到最少换乘次数的路径，而不仅仅是最短距离或最短时间。在这种情况下，BFS 算法通过优先选择同名线路，可以进一步减少实际的换乘次数，为乘客提供更便捷的旅行方案。这种方法利用了BFS算法的非加权性质，适用于在乘客换乘时考虑便利性和实际操作性。

**具体的BFS变体**：

​		使用**优先队列**（节点为{ nodeId, path, distanceSum, lastRoadName}），使用Set结构的visited避免重复计算，开始节点加入队列，后循环队列至空：弹出节点 => 判断是否到达终点，如果是则结束循环 => 遍历邻接边，如果没遍历过，则添加到visited、path等中，**如果上一个边的线路名与该邻接边一致，则加入到队列前端，否则加入到队列后端**。

TIP：**为什么你用于公交线路导航的时候使用BFS算法而不是DFS算法或者其他的算法？**

1. **最短路径优先**：**BFS算法是从起点开始，逐层向外扩展直至找到目标的算法，这使得它能够首先找到达目的地所需的最少转乘次数**。在公交系统导航中，通常用户更关心如何通过最少的换乘到达目的地，而BFS正好满足了这一需求。
2. **层次搜索**：**BFS按照距离起点的距离逐层搜索，这意味着它能够自然地处理各种交通工具之间的换乘问题**。比如，从起点到某个公交站可能有多条路线，BFS可以帮助我们找到包括步行和乘坐不同公交线路在内的最佳组合。
3. **实现简单，执行效率高**：相比于DFS和其他更复杂的算法（如A*搜索算法），BFS的实现更为简单直接。在大多数公交导航场景下，我们更关注于找到一条合理的路线而不是最优路线，BFS提供了一种高效的解决方案。
4. **更适合处理广度问题**：在公交导航的场景下，目标往往是在广泛的网络中找到有效的路径，而不是深入探索某一条路径。DFS在深度探索方面表现更好，但在广度搜索方面，BFS更能满足需求。
5. **避免深度过深的问题**：DFS算法可能会因为深度太深而陷入较长时间的搜索，特别是在复杂的公交网络中。BFS以层为单位进行搜索，避免了深度过深带来的效率问题。

总的来说，选择BFS算法进行公交线路导航是基于它在这个特定应用场景下的适用性和效率，特别是在寻找最少换乘次数的路线方面。

## 五、具体流程

1. 前端搜索框接收到用户输入的起点和终点的地点名后，发送请求至后端。后端通过模糊查询返回部分记录至前端用于给用户反馈。用户点击获得具体的POI名称后，根据选择是自驾导航还是公交导航选择路由，前端发送请求到后端。
2. 后端用具体的POI名称获取起点终点的坐标信息，并通过坐标信息用最近邻搜索算法得到最接近POI点的路网节点，得到起点终点的路网节点。将起点终点的路网节点id输入到具体的业务算法中，得到最短路径的边id，从数据库中读取到具体的边的json，发送至前端。
3. 前端接受返回的json，利用前端的GIS可视化库进行渲染。

## 六、难点

1. **数据准备与预处理的挑战**：导航系统需要处理大量的路网数据，包括道路、交叉口、公交线路和站点等。这些数据的复杂度和不一致性给算法实现带来了挑战。
2. **导航算法选择和实现的挑战**：根据自驾导航和公交导航的特点，选用合适的导航算法，后需要根据数据库中的路网构建网络，实现具体的算法。
3. **前后端搭建系统的挑战**：根据系统的特点和团队特点选用合适的技术栈，从UI设计、前端搭建、后端搭建到数据库设计等。
   1. **地图数据可视化的挑战**：如何在Canvas上渲染出矢量数据、瓦片数据以及如何在用户界面中清晰地展示搜索结果，特别是在路径规划中如何可视化显示路径和相关信息。

4. **性能优化的挑战**

## 七、地图可视化模块

这个地图可视化库通过多个模块的协作，提供了一个全面的解决方案来处理、渲染并展示地图数据。核心模块包括几何/属性类管理、要素和要素集的管理、符号定义、多种渲染方式以及图层控制等，进而构成了地图的绘制和交互操作的基础。特别地，地图模块整合了上述功能，支持地图视图的初始化、图层的动态管理和用户交互响应，实现了一个灵活且高效的地图可视化平台。

1. **几何模块**作为基础，定义了包括点、线、面等在内的几何实体数据结构。操作包括创建几何对象、读取GeoJson获取几何对象以及几何对象的处理等。
2. **要素模块**在几何模块之上构建，每个要素包括几何数据和属性数据，实现数据的基本封装。操作包括创建要素、读取和修改属性等。
3. **要素集模块**则是对多个要素的集合进行组织管理，包含了元数据定义、几何数据类型和要素字段等。操作包括添加、删除要素和查询要素集。
4. **符号模块**负责定义各种几何实体在视觉上的表示，如颜色、线宽等属性，还有注记符号等其他符号的属性。操作包括设置符号属性，绘制几何对象、注记对象等。
5. **渲染模块**根据符号模块的定义，实现了单一符号渲染、分类渲染和分段渲染等功能，使得不同类型或等级的要素可以有区分的视觉效果。单一符号渲染依据固定的符号对象来展示要素。分类渲染通过特定字段将要素分组，并对每组应用不同的符号和注记，同时统计各组数量。分级渲染则基于设定的数值范围对要素进行分层展示，每层使用不同的符号和注记。这三种渲染方式共同提供了灵活多样的地图表现形式，满足不同的可视化需求。
6. **要素图层模块**将要素集与具体的渲染方式结合起来，形成可在地图上展示的图层，每个图层包含了要素集、图层渲染对象和注记等。操作包括图层渲染和图层管理。
7. **瓦片地图模块**实现了一个相对独立的地图瓦片显示逻辑，它可以在原有地图上叠加额外的瓦片层，而不影响地图的其它操作。通过提供不同的瓦片服务URL，可以实现在同一个地图视图上显示来自不同源的地图瓦片。
8. **投影模块**包括了Web墨卡托投影的实现，包括了全球范围的BBox属性，对坐标点进行投影和逆投影。
9. **包络矩形模块**包含矩形的四至以及两个BBox之间的相交检测。
10. **注记模块**专门处理文本标注的显示，包括碰撞检测等功能，以确保地图上的文本清晰可读，不会相互重叠。操作包括配置注记属性等。
11. **地图模块**定义了地图库的核心功能，包含了中心点、BBox、Zoom层级、地图容器、图层集合等属性，实现了功能如地图的初始化、设置地图视图（包括中心点和缩放级别）、图层管理（添加、删除图层）和交互功能（如缩放、平移）。地图模块基于Canvas API根据要素图层集合的元素定义中心点、BBox，获得地图视图，进行地图数据绘制，并通过鼠标事件监测，实现漫游、缩放等操作。

每个模块通过明确的接口和数据结构相互协作，共同构成了一个功能丰富、结构清晰的地图可视化库。

**矢量数据绘制流程**：

1. 从地图对象中组织管理，按照层次依次调用地图对象绘制。
2. 对地图对象中管理的每一个图层，若图层可视且在图层的zoom可视范围内，则筛选出该图层内与可视区相交的要素，根据该图层管理的渲染对象，获取里面每一个要素对象对应的符号对象，调用要素对象的绘制。
3. 对图层中的要素集中管理的每一个要素，若要素可视，根据是否高亮分配符号对象，进一步调用几何对象的绘制。
4. 对几何对象，如果没有投影则进行投影，并去除可视区范围外的部分，后通过Canvas设置的转移矩阵，计算得到每一个坐标对应的屏幕坐标系坐标，调用几何对象的符号对象进行绘制。
5. 符号对象根据传入的屏幕坐标基于Canvas API进行绘制。

绘制流：**地图对象 => 图层对象 => 要素对象 => 几何对象 => 符号对象**

**瓦片地图数据绘制流程**：

1. **获取当前视图的范围**：首先确定渲染的地理空间要素的范围，即bounding box，找到左上角和右下角的经纬度；
1. **获取切片坐标和像素坐标**：然后将两点的经纬度坐标转换为瓦片坐标，用于确定在特定缩放级别下应该加载哪些瓦片。瓦片坐标通常是基于全球范围的瓦片网格系统，每一个缩放级别都有对应的瓦片数量，该数量是2的缩放级别次幂的平方。同时将左上角的像素坐标求出来，以求得知从哪里开始放置瓦片；
1. **设置左上角切片对应的image的top和left，其余切片按切片大小（默认256px）循环按从左到右从上到下排列**。


通过将数据和渲染过程组织成不同的模块和层次，如几何模块、要素和要素集模块、符号和渲染模块，以及图层管理，它展示了GIS数据从原始几何数据到可视化表示的分层处理过程。每个模块专注于GIS数据处理的不同方面，确保了数据管理的灵活性和可视化的多样性，同时也提高了系统的扩展性和维护性。#   N a v i g a t i o n M a p S y s t e m 
 
 
