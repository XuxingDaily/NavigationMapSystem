{"version":3,"file":"js/main.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;ACAA;AACA;AAGA;AAiBA;;AAEA;AACA;AACA;AAyHA;;;AAGA;AACA;AACA;AACA;AACA;AAgSA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAiDA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAKA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAmBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAIA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;ACzkBA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAIA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA+BA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClNA;AACA;AAGA;;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAWA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAAA;AAAA;AAOA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;;;;;;;;AASA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrNA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7EA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AAEA;AACA;AACA;AASA;AARA;AACA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAIA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxLA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAEA;;;AAGA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClMA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAcA;AAbA;AACA;AACA;AACA;AACA;AACA;AAyBA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAEA;;;AAGA;AACA;AACA;AAUA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlNA;;;;AAIA;AACA;;;;;;;;;;;;;;;;;;ACnBA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjFA;AACA;AAGA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAcA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxCA;AAIA;;AAEA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;AAIA;AACA;AAAA;AACA;;;;AAIA;AACA;AAqBA;AApBA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAAA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AA4DA;AA3DA;;;;;;;;AAQA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtJA;AACA;AAGA;AAIA;;AAEA;AACA;AACA;AACA;AAsBA;;AAEA;AACA;AAxBA;AACA;AACA;AACA;AAuBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzHA;;AAEA;AACA;AACA;AAqBA;AACA;AArBA;AACA;AACA;AACA;AAoBA;;;;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAQA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAGA;AAGA;AAGA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnHA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA;;;AAGA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;AClGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAeA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;;;;;;;;;;;;;;;;;AC1BA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpGA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3DA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3BA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjCA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAIA;;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AAOA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AAzBA;AACA;AACA;AACA;AACA;AACA;AAgCA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;;;;AAIA;AACA;AACA;AACA;AAQA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AA9BA;AACA;AACA;AACA;AACA;AACA;AACA;AA0BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAAA;;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAiDA;AA/CA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;AC1VA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AAEA;AAEA;AAqBA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AAEA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3IA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEhDA;AACA;AACA;AACA;AACA","sources":["webpack://navigation_gz/./view/style/init.css?3459","webpack://navigation_gz/./view/style/main.css?3d6d","webpack://navigation_gz/./src/core/Map.ts","webpack://navigation_gz/./src/core/element/Feature.ts","webpack://navigation_gz/./src/core/element/FeatureClass.ts","webpack://navigation_gz/./src/core/geometry/Geometry.ts","webpack://navigation_gz/./src/core/geometry/MultiPoint.ts","webpack://navigation_gz/./src/core/geometry/MultiPolygon.ts","webpack://navigation_gz/./src/core/geometry/MultiPolyline.ts","webpack://navigation_gz/./src/core/geometry/Point.ts","webpack://navigation_gz/./src/core/geometry/Polygon.ts","webpack://navigation_gz/./src/core/geometry/Polyline.ts","webpack://navigation_gz/./src/core/interaction/Interaction.ts","webpack://navigation_gz/./src/core/label/Label.ts","webpack://navigation_gz/./src/core/label/collision.ts","webpack://navigation_gz/./src/core/layer/FeatureLayer.ts","webpack://navigation_gz/./src/core/layer/Layer.ts","webpack://navigation_gz/./src/core/layer/Tiles.ts","webpack://navigation_gz/./src/core/render/Color.ts","webpack://navigation_gz/./src/core/render/Extent.ts","webpack://navigation_gz/./src/core/render/Field.ts","webpack://navigation_gz/./src/core/render/renderer/CategoryRenderer.ts","webpack://navigation_gz/./src/core/render/renderer/ClassRenderer.ts","webpack://navigation_gz/./src/core/render/renderer/Renderer.ts","webpack://navigation_gz/./src/core/render/renderer/SimpleRenderer.ts","webpack://navigation_gz/./src/core/render/symbol/FillSymbol.ts","webpack://navigation_gz/./src/core/render/symbol/LineSymbol.ts","webpack://navigation_gz/./src/core/render/symbol/PointSymbol.ts","webpack://navigation_gz/./src/core/render/symbol/Symbol.ts","webpack://navigation_gz/./src/core/utils/CreateElement.ts","webpack://navigation_gz/./src/core/utils/Loader.ts","webpack://navigation_gz/./src/index.ts","webpack://navigation_gz/./view/main.ts","webpack://navigation_gz/./view/utils.ts","webpack://navigation_gz/webpack/bootstrap","webpack://navigation_gz/webpack/runtime/chunk loaded","webpack://navigation_gz/webpack/runtime/define property getters","webpack://navigation_gz/webpack/runtime/global","webpack://navigation_gz/webpack/runtime/hasOwnProperty shorthand","webpack://navigation_gz/webpack/runtime/make namespace object","webpack://navigation_gz/webpack/runtime/publicPath","webpack://navigation_gz/webpack/runtime/jsonp chunk loading","webpack://navigation_gz/webpack/before-startup","webpack://navigation_gz/webpack/startup","webpack://navigation_gz/webpack/after-startup"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","import { scaleGeometry } from \"./interaction/Interaction\";\r\nimport { Extent } from \"./render/Extent\";\r\nimport { Layer } from \"./layer/Layer\";\r\nimport { Tiles } from \"./layer/Tiles\";\r\nimport { FeatureLayer } from \"../index\";\r\n\r\ninterface map {\r\n    /**\r\n     * 地图容器Div的ID\r\n     */\r\n    target: string,\r\n    /**\r\n     * 图层集\r\n     */\r\n    layers?: Layer[],\r\n    zoom?: number,\r\n    tile?: Tiles,\r\n    minZoom?: number,\r\n    maxZoom?: number\r\n}\r\n\r\n/**\r\n * 地图\r\n */\r\nexport class Map {\r\n    public constructor(config: map) {\r\n        // 传入参数\r\n        this._container = document.getElementById(config.target) as HTMLDivElement;\r\n        // 动态创建 canvas 调整高宽\r\n        this._canvas = document.createElement(\"canvas\");\r\n        this._canvas.style.cssText = \"position: absolute; height: 100vh; width: 100vw;\";\r\n        this._canvas.width = this._container.clientWidth;\r\n        this._canvas.height = this._container.clientHeight;\r\n        this._container.appendChild(this._canvas);\r\n        this._ctx = this._canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n        this._layers = config.layers ? config.layers : [];\r\n        this._zoom = config.zoom != null ? config.zoom : 3;\r\n        this._minZoom = config.minZoom != null ? config.minZoom : 3;\r\n        this._maxZoom = config.maxZoom != null ? config.maxZoom : 20;\r\n\r\n        this._layers.forEach(layer => {\r\n            layer.minZoom = this._minZoom;\r\n            layer.maxZoom = this._maxZoom;\r\n        })\r\n\r\n        // 获取图层最大Extent\r\n        this._layerExtent = this.getLayerExtent();\r\n        // 加载瓦片地图\r\n        this._tile = config.tile ? config.tile : null;\r\n        // 得到图层中心点（地理坐标）\r\n        this._center = this.getCenter(this._layerExtent);\r\n        // 根据图层中心点和图层Extent设置转移矩阵\r\n        // 视觉中心点（Canvas中心）为图层中心点\r\n        if (this._tile) {\r\n            this.setView(this._zoom);\r\n        } else {\r\n            this.setView(this._zoom, this._layerExtent);\r\n        }\r\n\r\n        // 获取此时的可视区范围（作渲染使用）\r\n        this._viewExtent = this.getViewExtent();\r\n        // 添加事件监听\r\n        this._addEventListener();\r\n    }\r\n\r\n    /**\r\n     * 地图容器\r\n     */\r\n    public _container: HTMLDivElement;\r\n    /**\r\n     * 一个地图框\r\n     */\r\n    private _canvas: HTMLCanvasElement;\r\n    /**\r\n     * Canvas绘图上下文\r\n     * @remarks 记录了转移矩阵等信息\r\n     */\r\n    private _ctx: CanvasRenderingContext2D;\r\n    /**\r\n     * 图层数组\r\n     */\r\n    private _layers: Layer[];\r\n    /**\r\n     * Canvas中心点的地理坐标\r\n     * @remarks 最初为图层中心点\r\n     */\r\n    private _center: number[];\r\n    /**\r\n     * 可视区范围\r\n     */\r\n    private _viewExtent: Extent;\r\n    /**\r\n     * 图层范围 - 所有Layer的最大Extent\r\n     */\r\n    private _layerExtent: Extent;\r\n    /**\r\n     * 瓦片地图\r\n     */\r\n    private _tile: Tiles;\r\n    /**\r\n     * 层级\r\n     */\r\n    private _zoom: number;\r\n    /**\r\n     * 最小层级\r\n     */\r\n    private _minZoom: number;\r\n    /**\r\n     * 最大层级\r\n     */\r\n    private _maxZoom: number;\r\n\r\n    public get container() {\r\n        return this._container;\r\n    }\r\n\r\n    public get ctx(): CanvasRenderingContext2D {\r\n        return this._ctx;\r\n    }\r\n\r\n    public set ctx(ctx: CanvasRenderingContext2D) {\r\n        this._ctx = ctx;\r\n    }\r\n\r\n    public get center(): number[] {\r\n        return this._center;\r\n    }\r\n\r\n    public get zoom() {\r\n        return this._zoom;\r\n    }\r\n\r\n    public get minZoom() {\r\n        return this._minZoom;\r\n    }\r\n    public set minZoom(zoom: number) {\r\n        this._minZoom = zoom;\r\n    }\r\n    public get maxZoom() {\r\n        return this._maxZoom;\r\n    }\r\n    public set maxZoom(zoom: number) {\r\n        this._maxZoom = zoom;\r\n    }\r\n\r\n    /**\r\n     * 回调函数\r\n     * @remarks 用于存在其他对象需要和Map一起调用回调函数的时候\r\n     */\r\n    private _events: any = {\r\n        move: [],\r\n        extent: []\r\n    };\r\n\r\n    public setTile(tile: Tiles) {\r\n        this._tile = tile;\r\n        this.setView(this._zoom, tile.extent);\r\n    }\r\n\r\n    /**\r\n     * 设置栅格瓦片地址\r\n     * @param url \r\n     */\r\n    public setTileURL(url: string): void {\r\n        this._tile.url = url;\r\n        this._tile.draw();\r\n    }\r\n\r\n    /**\r\n     * 获取全部图层的最大Extent\r\n     * @returns 最大Extent\r\n     */\r\n    public getLayerExtent(): Extent {\r\n        const extent_top = Math.max(...(this._layers.map(layer => { return (layer as any).extent.ymax; })));\r\n        const extent_bottom = Math.min(...(this._layers.map(layer => { return (layer as any).extent.ymin; })));\r\n        const extent_left = Math.min(...(this._layers.map(layer => { return (layer as any).extent.xmin; })));\r\n        const extent_right = Math.max(...(this._layers.map(layer => { return (layer as any).extent.xmax; })));\r\n        return new Extent(extent_top, extent_bottom, extent_left, extent_right);\r\n    }\r\n\r\n    /**\r\n     * 获取 Extent 的中心点 [x, y]\r\n     * @param extent [x, y]\r\n     * @returns \r\n     */\r\n    public getCenter(extent: Extent): number[] {\r\n        return [(extent.xmax + extent.xmin) / 2, (extent.ymax + extent.ymin) / 2];\r\n    }\r\n\r\n    /**\r\n     * 设置转换矩阵\r\n     * @param extent 图层范围\r\n     * @remarks 视觉中心点为 this.center\r\n     */\r\n    public setView(zoom: number = this._zoom, extent?: Extent): void {\r\n        this._zoom = Math.max(this._minZoom, Math.min(this._maxZoom, zoom));\r\n\r\n        const ex = extent ? extent : this.getLayerExtent();\r\n        const center = this.getCenter(ex);\r\n        const \r\n            a = this._canvas.height / (ex.ymax - ex.ymin) * ex.xscale,\r\n            d = this._canvas.height / (ex.ymax - ex.ymin) * ex.yscale,\r\n            e = this._container.clientWidth / 2 - a * center[0],\r\n            f = this._canvas.clientHeight / 2 - d * center[1];\r\n        this._ctx.setTransform(a, 0, 0, d, e, f);\r\n        this.redraw();\r\n        // const et = extent ? extent : this._tile.extent;\r\n        // const center = this.getCenter(et);\r\n        // const\r\n        //     a = 256 * Math.pow(2, this._zoom) / (et.xmax - et.xmin) * et.xscale,\r\n        //     d = 256 * Math.pow(2, this._zoom) / (et.ymax - et.ymin) * et.yscale,\r\n        //     e = this._canvas.width / 2 - a * center[0] - 150,\r\n        //     f = this._canvas.height / 2 - d * center[1] - 20;\r\n        // this._ctx.setTransform(a, 0, 0, d, e, f);\r\n        // this.redraw();\r\n    }\r\n\r\n    /**\r\n     * 根据转换矩阵得到可视区范围\r\n     * @return {Extent} 可视区范围\r\n     */\r\n    public getViewExtent(): Extent {\r\n        const matrix = this._ctx.getTransform();\r\n        const\r\n            x1: number = (0 - matrix.e) / matrix.a,\r\n            y1: number = (0 - matrix.f) / matrix.d,\r\n            x2: number = (this._canvas.width - matrix.e) / matrix.a,\r\n            y2: number = (this._canvas.height - matrix.f) / matrix.d;\r\n        return new Extent(Math.max(y1, y2), Math.min(y1, y2), Math.min(x1, x2), Math.max(x1, x2));\r\n    }\r\n\r\n    /**\r\n     * 地图动态事件监听\r\n     * @param event \r\n     * @param handler \r\n     */\r\n    public on(event: string, handler: Function): void {\r\n        this._events[event].push(handler);\r\n    }\r\n\r\n    /**\r\n     * 动态更新 ViewCenter和 ViewExtent\r\n     * @remarks\r\n     * 常用于事件\r\n     */\r\n    private updataView(): void {\r\n        this._layerExtent = this.getLayerExtent();\r\n        this._viewExtent = this.getViewExtent();\r\n        this._center = this.getCenter(this._viewExtent);\r\n        this._events.extent.forEach((handler: () => any) => handler());\r\n    }\r\n\r\n    /**\r\n     * 清除所有绘制的内容\r\n     */\r\n    public clear(): void {\r\n        // 先重置矩阵，清除绘图，后续会恢复矩阵\r\n        this._ctx.resetTransform();\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        // this._ctx.fillStyle = '#d1dadb'; // 设置背景颜色为浅蓝色\r\n        // this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height); // 绘制填充整个 Canvas 的矩形\r\n    }\r\n\r\n    /**\r\n     * 重绘\r\n     * @remarks\r\n     * 常见于事件后\r\n     */\r\n    public redraw(): void {\r\n        this._ctx.save();\r\n        this.clear();\r\n        this._ctx.restore();\r\n        // 更新 视觉中心 和 可视区范围\r\n        this.updataView();\r\n        // 绘制所有图层\r\n        this._layers.forEach(layer => {\r\n            layer.draw(this._ctx, this._viewExtent, this._zoom);\r\n        });\r\n        this._layers.filter(\r\n            layer => layer instanceof FeatureLayer && layer.labeled).forEach(\r\n                (layer) => {\r\n                    (layer as FeatureLayer).drawLabel(this._ctx, this.getViewExtent(), this._zoom);\r\n                });\r\n    }\r\n\r\n    /**\r\n     * 获取第K个图层\r\n     * @param K \r\n     * @returns \r\n     * @remarks K从1开始\r\n     */\r\n    public getLayer(K: number): Layer {\r\n        return this._layers[K - 1];\r\n    }\r\n\r\n    public getLayerByName(name: string): Layer {\r\n        for (const layer of this._layers) {\r\n            if (layer.name === name) {\r\n                return layer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public removeLayerByName(name: string) {\r\n        this.setView(this._zoom, this._layerExtent);\r\n        this._layers = this._layers.filter(layer => layer.name !== name);\r\n        this._layerExtent = this.getLayerExtent();\r\n        // 根据图层中心点和图层Extent设置转移矩阵\r\n        // 视觉中心点（Canvas中心）为图层中心点\r\n        if (this._tile) {\r\n            this.setView(this._zoom);\r\n        } else {\r\n            this.setView(this._zoom, this._layerExtent);\r\n        }\r\n        this.redraw();\r\n    }\r\n\r\n    /**\r\n     * 添加图层\r\n     * @param layer 图层\r\n     */\r\n    public pushLayer(layer: Layer): void {\r\n        this._layers.push(layer);\r\n        this._layerExtent = this.getLayerExtent();\r\n        // 根据图层中心点和图层Extent设置转移矩阵\r\n        // 视觉中心点（Canvas中心）为图层中心点\r\n        if (this._tile) {\r\n            this.setView(this._zoom);\r\n        } else {\r\n            this.setView(this._zoom, this._layerExtent);\r\n        }\r\n        this.redraw();\r\n    }\r\n\r\n    /**\r\n     * 插入图层为第K个图层\r\n     * @param K 第K个位置\r\n     * @param layer \r\n     * @remarks K从1开始\r\n     */\r\n    public insertLayer(K: number, layer: Layer): void {\r\n        this._layers.splice(K - 1, 0, layer);\r\n        this._layerExtent = this.getLayerExtent();\r\n        // 根据图层中心点和图层Extent设置转移矩阵\r\n        // 视觉中心点（Canvas中心）为图层中心点\r\n        if (this._tile) {\r\n            this.setView(this._zoom);\r\n        } else {\r\n            this.setView(this._zoom, this._layerExtent);\r\n        }\r\n        this.redraw();\r\n    }\r\n\r\n    // /**\r\n    //  * 添加图层\r\n    //  * @param layer 图层\r\n    //  */\r\n    // public addLayer(layer: Layer): void {\r\n    //     this._layers.push(layer);\r\n    //     // 获取图层最大Extent\r\n    //     this._layerExtent = this.getLayerExtent();\r\n    //     // 根据图层中心点和图层Extent设置转移矩阵\r\n    //     // 视觉中心点（Canvas中心）为图层中心点\r\n    //     if (this._tile) {\r\n    //         this.setView(this._zoom);\r\n    //     } else {\r\n    //         this.setView(this._zoom, this._layerExtent);\r\n    //     }\r\n    // }\r\n\r\n    /**\r\n     * 删除第 K 个图层\r\n     * @param K \r\n     * @returns 被删除图层\r\n     * @remarks K从1开始\r\n     */\r\n    public removeKthLayer(K: number): Layer {\r\n        const layer = this._layers.splice(K - 1, 1)[0];\r\n        this._layerExtent = this.getLayerExtent();\r\n        // 根据图层中心点和图层Extent设置转移矩阵\r\n        // 视觉中心点（Canvas中心）为图层中心点\r\n        if (this._tile) {\r\n            this.setView(this._zoom);\r\n        } else {\r\n            this.setView(this._zoom, this._layerExtent);\r\n        }\r\n        this.redraw();\r\n        return layer;\r\n    }\r\n\r\n    /**\r\n     * 删除图层\r\n     * @param layer 图层\r\n     * @returns 被删除图层\r\n     */\r\n    public removeLayer(layer: Layer): Layer {\r\n        const index = this._layers.findIndex(item => item === layer);\r\n        const delayer = this._layers.splice(index, 1)[0];\r\n        this._layerExtent = this.getLayerExtent();\r\n        // 根据图层中心点和图层Extent设置转移矩阵\r\n        // 视觉中心点（Canvas中心）为图层中心点\r\n        if (this._tile) {\r\n            this.setView(this._zoom);\r\n        } else {\r\n            this.setView(this._zoom, this._layerExtent);\r\n        }\r\n        this.redraw();\r\n        return delayer;\r\n    }\r\n\r\n    /**\r\n     * 置顶第K个图层\r\n     * @param K \r\n     * @remarks K从1开始\r\n     */\r\n    public upLayer(K: number): void {\r\n        const layer = this._layers.splice(K - 1, 1)[0];\r\n        this._layers.splice(0, 0, layer);\r\n        this.redraw();\r\n    }\r\n\r\n    /**\r\n     * 清空图层\r\n     */\r\n    public clearLayer(): void {\r\n        this._layers = [];\r\n        this.redraw();\r\n    }\r\n\r\n    public hiddenLayer(k: number) {\r\n        this._layers[k - 1].visible = false;\r\n        this.redraw();\r\n    }\r\n\r\n    public showLayer(k: number) {\r\n        this._layers[k - 1].visible = true;\r\n        this.redraw();\r\n    }\r\n\r\n    // -------------- 事件绑定 --------------- //\r\n\r\n    /**\r\n     * 鼠标事件的拖拽记录\r\n     */\r\n    private _drag: { flag: boolean, start: { x: number, y: number }, end: { x: number, y: number } } = {\r\n        flag: false,\r\n        start: {\r\n            x: 0,\r\n            y: 0\r\n        },\r\n        end: {\r\n            x: 0,\r\n            y: 0\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 统一绑定事件\r\n     */\r\n    private _addEventListener(): void {\r\n        this._onMouseDown = this._onMouseDown.bind(this);\r\n        this._onMouseMove = this._onMouseMove.bind(this);\r\n        this._onMouseUp = this._onMouseUp.bind(this);\r\n        this._onWheel = this._onWheel.bind(this);\r\n        this._onResize = this._onResize.bind(this);\r\n        this._onDoubleClick = this._onDoubleClick.bind(this);\r\n        this._canvas.addEventListener(\"mousedown\", this._onMouseDown);\r\n        this._canvas.addEventListener(\"mousemove\", this._onMouseMove);\r\n        this._canvas.addEventListener(\"mouseup\", this._onMouseUp);\r\n        this._canvas.addEventListener('wheel', this._onWheel);\r\n        this._canvas.addEventListener(\"dblclick\", this._onDoubleClick);\r\n        window.addEventListener(\"resize\", this._onResize);\r\n    }\r\n\r\n    /**\r\n     * 鼠标下压时记录位置\r\n     * @param event 鼠标事件\r\n     */\r\n    private _onMouseDown(event: MouseEvent): void {\r\n        this._drag.flag = true;\r\n        this._drag.start.x = event.x;\r\n        this._drag.start.y = event.y;\r\n    }\r\n\r\n    private _onDoubleClick(event: MouseEvent): void {\r\n        // 阻止冒泡\r\n        event.preventDefault();\r\n        let zoom = this._zoom + 2 >= this._maxZoom ? this._maxZoom - this._zoom : 2;\r\n        this._zoom += zoom;\r\n        let scale = Math.pow(2, zoom);\r\n        this._ctx = scaleGeometry(\r\n            this._ctx,\r\n            {\r\n                x: event.offsetX,\r\n                y: event.offsetY\r\n            },\r\n            scale\r\n        );\r\n        this.redraw();\r\n    }\r\n\r\n    /**\r\n     * 鼠标移动时带动几何图形并重绘\r\n     * @param event 鼠标事件\r\n     */\r\n    private _onMouseMove(event: MouseEvent): void {\r\n        if (!this._drag.flag) return;\r\n        // 鼠标下压的时候记录开始位置 移动的时候不断记录最终位置并转移\r\n        this._drag.end.x = event.x;\r\n        this._drag.end.y = event.y;\r\n        const matrix = this._ctx.getTransform();\r\n        this._ctx.translate(\r\n            (this._drag.end.x - this._drag.start.x) / matrix.a,\r\n            (this._drag.end.y - this._drag.start.y) / matrix.d\r\n        );\r\n        // 转移后该位置就是起始点\r\n        this._drag.start.x = event.x;\r\n        this._drag.start.y = event.y;\r\n        this.redraw();\r\n    }\r\n\r\n    /**\r\n     * 鼠标松开时不再记录\r\n     * @param event 鼠标事件\r\n     */\r\n    private _onMouseUp(event: MouseEvent): void {\r\n        this._drag.flag = false;\r\n    }\r\n\r\n    /**\r\n     * 滚轮事件绑定放大缩小并重绘\r\n     * @param event 滚轮事件\r\n     */\r\n    private _onWheel(event: WheelEvent): void {\r\n        // 阻止冒泡\r\n        event.preventDefault();\r\n        // 获取放大缩小的指数\r\n        let scale: number = 1;\r\n        const sensitivity: number = 100;\r\n        const delta: number = event.deltaY / sensitivity;\r\n        // 获取放大缩小的倍数 放大2 缩小0.5\r\n        delta < 0 ? scale *= delta * (-2) : scale /= delta * 2;\r\n\r\n        let zoom = Math.round(Math.log(scale));\r\n\r\n        if (zoom > 0) {\r\n            // 放大\r\n            zoom = this._zoom + zoom >= this._maxZoom ? this._maxZoom - this._zoom : zoom;\r\n        } else if (zoom < 0) {\r\n            // 缩小\r\n            zoom = this._zoom + zoom <= this._minZoom ? this._minZoom - this._zoom : zoom;\r\n        }\r\n\r\n        if (zoom == 0) return;\r\n        this._zoom += zoom;\r\n\r\n        scale = Math.pow(2, zoom);\r\n        // 通过变换矩阵进行变换\r\n        this._ctx = scaleGeometry(\r\n            this._ctx,\r\n            {\r\n                x: event.offsetX,\r\n                y: event.offsetY\r\n            },\r\n            scale\r\n        );\r\n\r\n        this.redraw();\r\n    }\r\n\r\n    /**\r\n     * 当浏览器大小变化的时候实时更新canvas大小\r\n     */\r\n    private _onResize(): void {\r\n        this._canvas.width = this._container.clientWidth;\r\n        this._canvas.height = this._container.clientHeight;\r\n        if (this._tile) {\r\n            this.setView(this._zoom);\r\n        } else {\r\n            this.setView(this._zoom, this._layerExtent);\r\n        }\r\n        this.redraw();\r\n    }\r\n\r\n}","import { Field } from \"../render/Field\";\r\nimport { FillSymbol } from \"../render/symbol/FillSymbol\";\r\nimport { LineSymbol } from \"../render/symbol/LineSymbol\";\r\nimport { PointSymbol, SimpleTextSymbol } from \"../render/symbol/PointSymbol\";\r\nimport { Extent } from \"../render/Extent\";\r\nimport { Geometry, GeometryType } from \"../geometry/Geometry\";\r\nimport { Symbol } from \"../render/symbol/Symbol\";\r\n\r\n/**\r\n * 要素\r\n */\r\nexport class Feature {\r\n    public constructor(geometry: Geometry, properties: any) {\r\n        // 放入geometry\r\n        this._geometry = geometry;\r\n        // 按顺序放入属性\r\n        this._properties = properties;\r\n        // 默认下可视\r\n        this.visible = true;\r\n        // 默认下不开启高亮\r\n        this.isHeightLighted = false;\r\n    }\r\n\r\n    /**\r\n     * 要素是否可视\r\n     */\r\n    public visible: boolean;\r\n    /**\r\n     * 要素几何图形\r\n     */\r\n    private _geometry: Geometry;\r\n    /**\r\n     * 要素属性\r\n     */\r\n    private _properties: any;\r\n    /**\r\n     * 是否高亮\r\n     */\r\n    public isHeightLighted: boolean;\r\n    /**\r\n     * 标注符号\r\n     */\r\n    protected _text: SimpleTextSymbol;\r\n\r\n    public get text() {\r\n        return this._text;\r\n    }\r\n\r\n    public set text(t: SimpleTextSymbol) {\r\n        this._text = t;\r\n    }\r\n\r\n    /**\r\n     * 要素几何图形\r\n     */\r\n    public get geometry(): Geometry {\r\n        return this._geometry;\r\n    }\r\n    /**\r\n     * 要素属性\r\n     */\r\n    public get properties(): Field[] {\r\n        return this._properties;\r\n    }\r\n    /**\r\n     * 要素几何图形包络矩形\r\n     */\r\n    public get extent(): Extent | null {\r\n        return this._geometry ? this._geometry.getExtent() : null;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * 标注要素\r\n     * @remarks 调用空间坐标信息进行标注绘制\r\n     * @param {Field} field - 标注字段\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {SimpleTextSymbol} symbol - 标注符号\r\n     */\r\n    label(field: Field, ctx: CanvasRenderingContext2D, symbol: SimpleTextSymbol = new SimpleTextSymbol()) {\r\n        if (this.visible) \r\n            this._geometry.label(this._properties[field.name], ctx, this._text ? this._text : symbol);\r\n    }\r\n\r\n    /**\r\n     * 绘制几何图形\r\n     * @param ctx Canvas画笔\r\n     * @param extent 可视区范围\r\n     * @param symbol 几何图形符号\r\n     */\r\n    public draw(ctx: CanvasRenderingContext2D, extent: Extent, symbol: Symbol): void {\r\n        if (this.visible) {\r\n            if (this.isHeightLighted) {\r\n                let heightLightSymbol: Symbol = new Symbol(1, \"#1286d3\", \"#88deff\");\r\n                switch (this._geometry.type) {\r\n                    case GeometryType.Point || GeometryType.MultiPoint:\r\n                        heightLightSymbol = new PointSymbol(1, \"#1286d3\", \"#88deff\");\r\n                        break;\r\n\r\n                    case GeometryType.Polyline || GeometryType.MultiPolyline:\r\n                        heightLightSymbol = new LineSymbol(1, \"#1286d3\");\r\n                        break;\r\n\r\n                    case GeometryType.Polygon || GeometryType.MultiPolygon:\r\n                        heightLightSymbol = new FillSymbol(1, \"#1286d3\", \"#88deff\");\r\n                        break;\r\n\r\n                    case GeometryType.MultiPoint:\r\n                        heightLightSymbol = new PointSymbol(1, \"#1286d3\", \"#88deff\", (this._geometry as any)._symbol.radius);\r\n                        break;\r\n\r\n                    case GeometryType.MultiPolyline:\r\n                        heightLightSymbol = new LineSymbol(1, \"#1286d3\");\r\n                        break;\r\n\r\n                    case GeometryType.MultiPolygon:\r\n                        heightLightSymbol = new FillSymbol(1, \"#1286d3\", \"#88deff\");\r\n                        break;\r\n\r\n                    default:\r\n                        break;\r\n                }\r\n                this._geometry.draw(ctx, extent, heightLightSymbol);\r\n            } else {\r\n                this._geometry.draw(ctx, extent, symbol);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 判断要素与可视区范围是否交叉\r\n     * @param extent 可视区范围\r\n     * @returns \r\n     */\r\n    public intersect(extent: Extent): boolean {\r\n        if (this.visible) return this._geometry.getExtent().intersect(extent);\r\n        else return false;\r\n    }\r\n\r\n}","import { GeometryType } from \"../geometry/Geometry\";\r\nimport { Field, FieldDataType } from \"../render/Field\";\r\nimport { Feature } from \"./Feature\";\r\nimport { Point } from \"../geometry/Point\";\r\nimport { Polyline } from \"../geometry/Polyline\";\r\nimport { Polygon } from \"../geometry/Polygon\";\r\nimport { MultiPoint } from \"../geometry/MultiPoint\";\r\nimport { MultiPolyline } from \"../geometry/MultiPolyline\";\r\nimport { MultiPolygon } from \"../geometry/MultiPolygon\";\r\nimport { Label } from \"../label/Label\";\r\n\r\n/**\r\n * 要素集\r\n */\r\nexport class FeatureClass {\r\n    public constructor(type: GeometryType, { features = [], fields = [], name = \"\", alias = \"\", description = \"\" }: any = {}) {\r\n        this.name = name;\r\n        this.alias = alias;\r\n        this.description = description;\r\n        this._features = features;\r\n        this._featureLength = features.length;\r\n        this._fields = fields;\r\n        this._type = type;\r\n    }\r\n\r\n    /**\r\n     * 要素集名称\r\n     */\r\n    public name: string;\r\n    /**\r\n     * 要素集别称\r\n     */\r\n    public alias: string;\r\n    /**\r\n     * 要素集描述\r\n     */\r\n    public description: string;\r\n    /**\r\n     * 要素集几何图形类型\r\n     */\r\n    private _type: GeometryType;\r\n    /**\r\n     * 要素集各个要素\r\n     */\r\n    private _features: Feature[];\r\n    /**\r\n     * 要素集要素个数\r\n     */\r\n    private _featureLength: number;\r\n    /**\r\n     * 要素集的各个字段\r\n     */\r\n    private _fields: Field[];\r\n\r\n    /**\r\n     * 要素集几何图形类型\r\n     */\r\n    public get type(): GeometryType { return this._type; }\r\n    /**\r\n     * 要素集各个要素\r\n     */\r\n    public get features(): Feature[] { return this._features; }\r\n    /**\r\n     * 要素集各个字段\r\n     */\r\n    public get fields(): Field[] { return this._fields; }\r\n    /**\r\n     * 要素集要素个数\r\n     */\r\n    public get length(): number { return this._featureLength; }\r\n\r\n    /**\r\n     * 添加 Feature\r\n     * @param feature \r\n     */\r\n    public addFeature(feature: Feature): void {\r\n        this._features.push(feature);\r\n        this._featureLength++;\r\n    }\r\n\r\n    /**\r\n     * 删除指定 Feature\r\n     * @param feature \r\n     * @returns 删去Feature所在的位置\r\n     */\r\n    public removeFeature(feature: Feature): number {\r\n        const index: number = this._features.findIndex(item => item === feature);\r\n        if (index !== -1) this._features.splice(index, 1);\r\n        this._featureLength--;\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * 删除指定位置的 Feature\r\n     * @param K \r\n     * @returns 该位置的 Feature\r\n     */\r\n    public removeKth(K: number): Feature {\r\n        const feature: Feature[] = this._features.splice(K, 1);\r\n        this._featureLength--;\r\n        return feature[0];\r\n    }\r\n\r\n    /**\r\n     * 清空 FeatureClass\r\n     */\r\n    public clearFeature(): void {\r\n        this._features = [];\r\n        this._featureLength = 0;\r\n    }\r\n\r\n    /**\r\n     * 添加指定字段\r\n     * @param field 字段\r\n     */\r\n    public addField(field: Field): void {\r\n        this._fields.push(field);\r\n    }\r\n\r\n    /**\r\n     * 删除指定字段\r\n     * @param field 字段\r\n     */\r\n    public removeField(field: Field): void {\r\n        const index = this._fields.findIndex(item => item === field);\r\n        if (index !== -1) this._fields.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * 清空字段\r\n     */\r\n    public clearField(): void {\r\n        this._fields = [];\r\n    }\r\n\r\n    /**\r\n     * 解析 GeoJson\r\n     * @param data geojson转后对象\r\n     */\r\n    public static fromGeoJson(opts: { type: GeometryType, data: any, name?: string, alias?: string, description?: string }): FeatureClass {\r\n        const features: Feature[] = [];\r\n\r\n        Array.isArray(opts.data.features) && opts.data.features.forEach((feature: any) => {\r\n            switch (feature.geometry.type) {\r\n                case \"Point\":\r\n                    const point = new Point(feature.geometry.coordinates);\r\n                    features.push(new Feature(point, feature.properties));\r\n                    break;\r\n\r\n                case \"LineString\":\r\n                    const line = new Polyline(feature.geometry.coordinates);\r\n                    features.push(new Feature(line, feature.properties));\r\n                    break;\r\n\r\n                case \"Polygon\":\r\n                    const surface = new Polygon(feature.geometry.coordinates);\r\n                    features.push(new Feature(surface, feature.properties));\r\n                    break;\r\n\r\n                case \"MultiPoint\":\r\n                    const multiPoint = new MultiPoint(feature.geometry.coordinates);\r\n                    features.push(new Feature(multiPoint, feature.properties));\r\n                    break;\r\n\r\n                case \"MultiLineString\":\r\n                    const multiLineString = new MultiPolyline(feature.geometry.coordinates);\r\n                    features.push(new Feature(multiLineString, feature.properties));\r\n                    break;\r\n\r\n                case \"MultiPolygon\":\r\n                    const multiPolygon = new MultiPolygon(feature.geometry.coordinates);\r\n                    features.push(new Feature(multiPolygon, feature.properties));\r\n                    break;\r\n\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n\r\n        // 统计字段\r\n        const items: {name: string, type: string}[] = [];\r\n        for (let feature of features) {\r\n            feature.properties && Object.entries(feature.properties).forEach(p => {\r\n                let flag = true;\r\n                const item = {\r\n                    name: p ? p[0] : \"\",\r\n                    type: typeof(p[1])\r\n                };\r\n                for (let field of items) {\r\n                    if (field.name == item.name)\r\n                        flag = false;\r\n                }\r\n                if (flag)\r\n                    items.push(item);\r\n            })\r\n        }\r\n        const fields: Field[] = [];\r\n        for (let item of items) {\r\n            const type = item.type === \"number\" ? FieldDataType.Number : FieldDataType.Text;\r\n            fields.push(new Field(item.name, type));\r\n        }\r\n\r\n        return new FeatureClass(opts.type, {\r\n            features: features,\r\n            name: opts.name ? opts.name : \"\",\r\n            alias: opts.alias ? opts.alias : \"\",\r\n            description: opts.description ? opts.description : \"\",\r\n            fields: fields\r\n        });\r\n    }\r\n}","import { SimpleTextSymbol } from \"../../index\";\r\nimport { Extent } from \"../render/Extent\";\r\nimport { Symbol } from \"../render/symbol/Symbol\";\r\n\r\n/**\r\n * 几何图形类型\r\n */\r\nexport enum GeometryType {\r\n    Point, Polyline, Polygon, MultiPoint, MultiPolyline, MultiPolygon\r\n}\r\n\r\n/**\r\n * 几何图形基类\r\n */\r\nexport abstract class Geometry {\r\n    public constructor() {\r\n        this._extent = new Extent(0, 0, 0, 0);\r\n        this._type = GeometryType.Point;\r\n    }\r\n\r\n    /**\r\n     * 几何图形类型\r\n     */\r\n    protected _type: GeometryType;\r\n    /**\r\n     * 几何图形包络矩形\r\n     */\r\n    protected _extent: Extent;\r\n\r\n    /**\r\n     * 几何图形类型\r\n     */\r\n    public get type(): GeometryType {\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * 包络矩形\r\n     */\r\n    public get extent(): Extent {\r\n        return this._extent;\r\n    }\r\n\r\n    /**\r\n     * 判断两个几何图像是否相交\r\n     * @param {Extent} extent \r\n     * @returns {boolean} 是否相交\r\n     */\r\n    public intersect(extent: Extent): boolean {\r\n        return extent.intersect(this._extent);\r\n    }\r\n\r\n    /**\r\n     * 绘出几何图像（虚函数）\r\n     * @param ctx Canvas画笔\r\n     * @param extent 可视区四至\r\n     * @param symbol 要素样式\r\n     */\r\n    public async draw(ctx: CanvasRenderingContext2D, extent: Extent, symbol: Symbol): Promise<void> { }\r\n\r\n    /**\r\n     * 转为geojson\r\n     */\r\n    public abstract toGeoJson(): any;\r\n\r\n    /**\r\n  * 标注绘制\r\n  * @remarks\r\n  * 标注文本支持多行，/r/n换行\r\n  * @param {string} text - 标注文本\r\n  * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n  * @param {SimpleTextSymbol} symbol - 标注符号\r\n  */\r\n    label(text: string, ctx: CanvasRenderingContext2D, symbol: SimpleTextSymbol = new SimpleTextSymbol()) {\r\n        if (!text) \r\n            return;\r\n        \r\n        ctx.save();\r\n        ctx.strokeStyle = symbol.strokeStyle;\r\n        ctx.fillStyle = symbol.fillStyle;\r\n        ctx.lineWidth = symbol.lineWidth;\r\n        ctx.lineJoin = \"round\";\r\n        ctx.font = symbol.fontSize + \"px/1 \" + symbol.fontFamily + \" \" + symbol.fontWeight;\r\n        const center = this.getCenter();\r\n        const matrix = (ctx as any).getTransform();\r\n        \r\n        //keep pixel\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        const array = text.toString().split(\"/r/n\");\r\n        let widths = array.map(str => ctx.measureText(str).width + symbol.padding * 2);\r\n        let width = Math.max(...widths);\r\n        let height = symbol.fontSize * array.length + symbol.padding * 2 + symbol.padding * (array.length - 1);\r\n\r\n        const screenX = (matrix.a * center[0] + matrix.e);\r\n        const screenY = (matrix.d * center[1] + matrix.f);\r\n        \r\n        let totalX: number, totalY: number;\r\n        switch (symbol.placement) {\r\n            case \"TOP\":\r\n                totalX = - width / 2;\r\n                totalY = - symbol.pointSymbolHeight / 2 - height;\r\n                break;\r\n            case \"BOTTOM\":\r\n                totalX = - width / 2;\r\n                totalY = symbol.pointSymbolHeight / 2;\r\n                break;\r\n            case \"RIGHT\":\r\n                totalX = symbol.pointSymbolWidth / 2;\r\n                totalY = - height / 2;\r\n                break;\r\n            case \"LEFT\":\r\n                totalX = - symbol.pointSymbolWidth / 2 - width;\r\n                totalY = - height / 2;\r\n                break;\r\n        }\r\n        ctx.strokeRect(screenX + totalX, screenY + totalY, width, height);\r\n        ctx.fillRect(screenX + totalX, screenY + totalY, width, height);\r\n        ctx.textBaseline = \"top\";\r\n        ctx.fillStyle = symbol.fontColor;\r\n        array.forEach((str, index) => {\r\n            ctx.fillText(str, screenX + totalX + symbol.padding + (width - widths[index]) / 2, screenY + totalY + symbol.padding + index * (symbol.fontSize + symbol.padding));\r\n        });\r\n        ctx.restore();\r\n    };\r\n\r\n    /**\r\n     * 标注量算\r\n     * @remarks\r\n     * 标注文本支持多行，/r/n换行\r\n     * 目前用于寻找自动标注最合适的方位：top bottom left right\r\n     * @param {string} text - 标注文本\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @param {SimpleTextSymbol} symbol - 标注符号\r\n     */\r\n    measure(text: string, ctx: CanvasRenderingContext2D, symbol: SimpleTextSymbol = new SimpleTextSymbol()) {\r\n        if (!text) return;\r\n        ctx.save();\r\n        ctx.font = symbol.fontSize + \"px/1 \" + symbol.fontFamily + \" \" + symbol.fontWeight;\r\n        const center = this.getCenter();\r\n        const matrix = (ctx as any).getTransform();\r\n        //keep pixel\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        const array = text.toString().split(\"/r/n\");\r\n        let widths = array.map(str => ctx.measureText(str).width + symbol.padding * 2);\r\n        let width = Math.max(...widths);\r\n        let height = symbol.fontSize * array.length + symbol.padding * 2 + symbol.padding * (array.length - 1);\r\n        const screenX = (matrix.a * center[0] + matrix.e);\r\n        const screenY = (matrix.d * center[1] + matrix.f);\r\n        ctx.restore();\r\n        let totalX: number, totalY: number;\r\n        switch (symbol.placement) {\r\n            case \"TOP\":\r\n                totalX = - width / 2;\r\n                totalY = - symbol.pointSymbolHeight / 2 - height;\r\n                break;\r\n            case \"BOTTOM\":\r\n                totalX = - width / 2;\r\n                totalY = symbol.pointSymbolHeight / 2;\r\n                break;\r\n            case \"RIGHT\":\r\n                totalX = symbol.pointSymbolWidth / 2;\r\n                totalY = - height / 2;\r\n                break;\r\n            case \"LEFT\":\r\n                totalX = - symbol.pointSymbolWidth / 2 - width;\r\n                totalY = - height / 2;\r\n                break;\r\n        }\r\n        \r\n        return new Extent(screenY + totalY + height,  screenY + totalY, screenX + totalX,screenX + totalX + width);\r\n    };\r\n\r\n    /**\r\n     * 获取两个图形间距离\r\n     * @remarks\r\n     * 当前为两图形中心点间的直线距离\r\n     * 多用于聚合判断\r\n     * @param {Geometry} geometry - 另一图形\r\n     * @param {CoordinateType} type - 坐标类型\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {number} 距离\r\n     */\r\n    public distance(geometry: Geometry, ctx: CanvasRenderingContext2D) {\r\n        const center = this.getCenter();\r\n        const point = geometry.getCenter();\r\n        const matrix = (ctx as any).getTransform();\r\n        const screenX1 = (matrix.a * center[0] + matrix.e), screenY1 = (matrix.d * center[1] + matrix.f);\r\n        const screenX2 = (matrix.a * point[0] + matrix.e), screenY2 = (matrix.d * point[1] + matrix.f);\r\n        return Math.sqrt((screenX2-screenX1) * (screenX2-screenX1) + (screenY2-screenY1) * (screenY2-screenY1));\r\n    }\r\n\r\n    /**\r\n     * 判断鼠标点是否在几何图形范围内\r\n     * @param screenCoordinate 鼠标屏幕坐标\r\n     * @returns {boolean}\r\n     */\r\n    public abstract contain(screenCoordinate: number[]): boolean;\r\n\r\n    /**\r\n     * 获取几何图像中心点坐标（虚函数）\r\n     * @returns {number[]} 几何图形中心点坐标\r\n     */\r\n    public abstract getCenter(): number[];\r\n\r\n    /**\r\n     * 获取几何图形包络矩形\r\n     * @remarks 主要用于图像刚刚建立的时候\r\n     * @returns {Extent} 几何图形包络矩形\r\n     */\r\n    public abstract getExtent(): Extent;\r\n\r\n}\r\n","import { Extent } from \"../render/Extent\";\r\nimport { PointSymbol } from \"../render/symbol/PointSymbol\";\r\nimport { Geometry, GeometryType } from \"./Geometry\";\r\n\r\n\r\nexport class MultiPoint extends Geometry {\r\n    public constructor(coordinates: number[][]) {\r\n        super();\r\n        this._geoCoordinates = coordinates;\r\n        this._screenCoordinates = [];\r\n        this._symbol = new PointSymbol();\r\n        this._extent = this.getExtent();\r\n        this._type = GeometryType.MultiPoint;\r\n    }\r\n\r\n    /**\r\n     * 多点类型几何图形地理坐标\r\n     * @remarks 格式：[[x1, y1], [x2, y2], ...]\r\n     */\r\n    private _geoCoordinates: number[][];\r\n    /**\r\n     * 多点类型几何图形屏幕坐标\r\n     * @remarks 通过转移矩阵计算所得\r\n     */\r\n    private _screenCoordinates: number[][];\r\n    /**\r\n     * 多点类型几何图形符号\r\n     */\r\n    private _symbol: PointSymbol;\r\n\r\n    public toGeoJson() {\r\n        return {\r\n            \"type\": \"MultiPoint\",\r\n            \"coordinates\": this._geoCoordinates\r\n        };\r\n    }\r\n\r\n    public async draw(ctx: CanvasRenderingContext2D, extent: Extent, symbol: PointSymbol = new PointSymbol): Promise<void> {\r\n        // 渲染可视区范围内的几何图像\r\n        if (!extent.intersect(this._extent)) \r\n            return;\r\n\r\n        // 获得屏幕坐标\r\n        const matrix = ctx.getTransform();\r\n        this._screenCoordinates = this._geoCoordinates.map(point => {\r\n            return [(matrix.a * point[0] + matrix.e), (matrix.d * point[1] + matrix.f)];\r\n        });\r\n        // 获取Symbol\r\n        this._symbol = symbol;\r\n        // 绘制线类型几何图像\r\n        this._screenCoordinates.forEach(point => {\r\n            this._symbol.draw(ctx, point);\r\n        });\r\n    }\r\n\r\n    public getCenter(): number[] {\r\n        return [];\r\n    }\r\n\r\n    public getExtent(): Extent {\r\n\r\n        let arr: number[][] = this._geoCoordinates;\r\n        \r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        arr.forEach(point => {\r\n            xmin = Math.min(xmin, point[0]);\r\n            ymin = Math.min(ymin, point[1]);\r\n            xmax = Math.max(xmax, point[0]);\r\n            ymax = Math.max(ymax, point[1]);\r\n        });\r\n\r\n        return new Extent(ymax, ymin, xmin, xmax);\r\n    }\r\n\r\n    public contain(screenCoordinate: number[]): boolean {\r\n        return false;\r\n    }\r\n}","import { Extent } from \"../render/Extent\";\r\nimport { FillSymbol } from \"../render/symbol/FillSymbol\";\r\nimport { Geometry, GeometryType } from \"./Geometry\";\r\n\r\nexport class MultiPolygon extends Geometry {\r\n    public constructor(coordinates: number[][][][]) {\r\n        super();\r\n        this._geoCoordinates = coordinates;\r\n        this._screenCoordinates = [];\r\n        this._symbol = new FillSymbol();\r\n        this._extent = this.getExtent();\r\n        this._type = GeometryType.Polygon;\r\n    }\r\n\r\n    private _geoCoordinates: number[][][][];\r\n    private _screenCoordinates: number[][][][];\r\n\r\n    private _symbol: FillSymbol;\r\n\r\n    public toGeoJson() {\r\n        return {\r\n            \"type\": \"MultiPolygon\",\r\n            \"coordinates\": this._geoCoordinates\r\n        };\r\n    }\r\n\r\n    public async draw(ctx: CanvasRenderingContext2D, extent: Extent, symbol: FillSymbol = new FillSymbol()): Promise<void> {\r\n        // 只渲染可视区范围内元素\r\n        if (!extent.intersect(this._extent))\r\n            return;\r\n\r\n        const matrix = ctx.getTransform();\r\n        // 获取屏幕坐标\r\n        this._screenCoordinates = this._geoCoordinates.map(polygon => polygon.map(ring => ring.map(point => {\r\n            return [(matrix.a * point[0] + matrix.e), (matrix.d * point[1] + matrix.f)];\r\n        })));\r\n        // 获取Symbol\r\n        this._symbol = symbol;\r\n        // 绘制\r\n        this._screenCoordinates.forEach(polygon => {\r\n            this._symbol.draw(ctx, polygon);\r\n        })\r\n    }\r\n\r\n    public getCenter(): number[] {\r\n        let i, j, p1, p2, f, area, x, y, center;\r\n        // get more points polygon\r\n        const counts: any = this._geoCoordinates.map( polygon => {\r\n            let count = 0;\r\n            polygon.forEach( ring => {\r\n                count = count + ring.length;\r\n            })\r\n            return count;\r\n        });\r\n        let index = counts.indexOf(Math.max(...counts));\r\n        let points = this._geoCoordinates[index][0],\r\n            len = points.length;\r\n        if (!len) { return null; }\r\n\r\n        // polygon centroid algorithm; only uses the first ring if there are multiple\r\n\r\n        area = x = y = 0;\r\n\r\n        for (i = 0, j = len - 1; i < len; j = i++) {\r\n            p1 = points[i];\r\n            p2 = points[j];\r\n\r\n            f = p1[1] * p2[0] - p2[1] * p1[0];\r\n            x += (p1[0] + p2[0]) * f;\r\n            y += (p1[1] + p2[1]) * f;\r\n            area += f * 3;\r\n        }\r\n\r\n        if (area === 0) {\r\n            // Polygon is so small that all points are on same pixel.\r\n            center = points[0];\r\n        } else {\r\n            center = [x / area, y / area];\r\n        }\r\n\r\n        return center;\r\n        \r\n    }\r\n\r\n    public getExtent(): Extent {\r\n        let arr: number[][][][] = this._geoCoordinates;\r\n\r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        arr.forEach(polygon => {\r\n            polygon.forEach(ring => {\r\n                ring.forEach(point => {\r\n                    xmin = Math.min(xmin, point[0]);\r\n                    ymin = Math.min(ymin, point[1]);\r\n                    xmax = Math.max(xmax, point[0]);\r\n                    ymax = Math.max(ymax, point[1]);\r\n                })\r\n            })\r\n        });\r\n        return new Extent(ymax, ymin, xmin, xmax);\r\n    }\r\n\r\n    public contain(screenCoordinate: number[]): boolean {\r\n        //first ring contained && others no contained\r\n        const _pointInPolygon = (point: number[], vs: number[][]) => {\r\n            let x = point[0], y = point[1];\r\n\r\n            let inside = false;\r\n            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n                let xi = vs[i][0], yi = vs[i][1];\r\n                let xj = vs[j][0], yj = vs[j][1];\r\n\r\n                let intersect = ((yi > y) != (yj > y))\r\n                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\r\n                if (intersect) inside = !inside;\r\n            }\r\n\r\n            return inside;\r\n        };\r\n        //TODO: only test first polygon, ring is not supported\r\n        return this._screenCoordinates.some(polygon => _pointInPolygon(screenCoordinate, polygon[0]));\r\n    }\r\n\r\n    public getArea(): number {\r\n        let sum = 0;\r\n        this._geoCoordinates.forEach(polygon => {\r\n            polygon.forEach((ring, index) => {\r\n                if (index == 0) {\r\n                    ring.forEach((point, index) => {\r\n                        if (index > 0) {\r\n                            //梯形面积\r\n                            sum += 1 / 2 * (point[0] - ring[index - 1][0]) * (point[1] + ring[index - 1][1]);\r\n                        }\r\n                    })\r\n                    sum += 1 / 2 * (ring[0][0] - ring[ring.length - 1][0]) * (ring[ring.length - 1][1] + ring[0][1]);\r\n                }\r\n            });\r\n        });\r\n        //顺时针为正，逆时针为负\r\n        return Math.abs(sum);\r\n    }\r\n\r\n    /**\r\n     * 获取面类型几何图形的周长\r\n     * @returns 周长\r\n     */\r\n    public getPerimeter(): number {\r\n        let primeter: number = 0;\r\n        this._geoCoordinates.forEach(polygon => {\r\n            polygon.forEach(ring => {\r\n                ring.reduce((pre, cur) => {\r\n                    primeter += this.calculationDistance(pre, cur);\r\n                    return cur;\r\n                });\r\n            })\r\n        });\r\n        return primeter;\r\n    }\r\n\r\n    /**\r\n     * 求点1到点2的距离\r\n     * @param point1 点1\r\n     * @param point2 点2\r\n     * @returns {number} 点1到点2的距离\r\n     */\r\n    private calculationDistance(point1: number[], point2: number[]): number {\r\n        return Math.pow((point2[0] - point1[0]), 2) + Math.pow((point2[1] - point1[1]), 2);\r\n    }\r\n\r\n}","import { Extent } from \"../render/Extent\";\r\nimport { LineSymbol } from \"../render/symbol/LineSymbol\";\r\nimport { Geometry, GeometryType } from \"./Geometry\";\r\n\r\nexport class MultiPolyline extends Geometry {\r\n    public constructor(coordinates: number[][][]) {\r\n        super();\r\n        this._geoCoordinates = coordinates;\r\n        this._screenCoordinates = [];\r\n        this._symbol = new LineSymbol();\r\n        this._extent = this.getExtent();\r\n        this._type = GeometryType.MultiPolyline;\r\n    }\r\n\r\n    protected static TOLERANCE: number = 4;\r\n    protected _tolerance: number = 4;\r\n\r\n    /**\r\n     * 多线类型几何图形地理坐标\r\n     * @remarks 格式： [[[x1, y1], [x2, y2], ...], [[x1, y1], [x2, y2], ...]]\r\n     */\r\n    private _geoCoordinates: number[][][];\r\n    /**\r\n     * 线类型几何图形屏幕坐标\r\n     * @remarks 通过转移矩阵计算所得\r\n     */\r\n    private _screenCoordinates: number[][][];\r\n    /**\r\n     * 线类型几何图形符号\r\n     */\r\n    private _symbol: LineSymbol;\r\n\r\n    public toGeoJson() {\r\n        return {\r\n            \"type\": \"MultiLineString\",\r\n            \"coordinates\": this._geoCoordinates\r\n        };\r\n    }\r\n\r\n    public async draw(ctx: CanvasRenderingContext2D, extent: Extent , symbol: LineSymbol = new LineSymbol()): Promise<void> {\r\n        this._tolerance = symbol.lineWidth + symbol.lineWidth;\r\n        // 只渲染可视区范围内元素\r\n        if (!extent.intersect(this._extent))\r\n            return;\r\n\r\n        const matrix = ctx.getTransform();\r\n        // 获取屏幕坐标\r\n        this._screenCoordinates = this._geoCoordinates.map(ring => {\r\n            return ring.map(point => {\r\n                return [(matrix.a * point[0] + matrix.e), (matrix.d * point[1] + matrix.f)];\r\n            });\r\n        });\r\n        // 获取Symbol\r\n        this._symbol = symbol;\r\n        // 绘制\r\n        this._screenCoordinates.forEach(ring => {\r\n            this._symbol.draw(ctx, ring);\r\n        });\r\n    }\r\n\r\n    public getCenter(): number[] {\r\n        let i, halfDist, segDist, dist, p1, p2, ratio,\r\n            points = this._geoCoordinates[0],\r\n            len = points.length;\r\n\r\n        if (!len) { return null; }\r\n\r\n        // polyline centroid algorithm; only uses the first ring if there are multiple\r\n\r\n        for (i = 0, halfDist = 0; i < len - 1; i++) {\r\n            halfDist += Math.sqrt((points[i + 1][0] - points[i][0]) * (points[i + 1][0] - points[i][0]) + (points[i + 1][1] - points[i][1]) * (points[i + 1][1] - points[i][1])) / 2;\r\n        }\r\n\r\n        let center;\r\n        // The line is so small in the current view that all points are on the same pixel.\r\n        if (halfDist === 0) {\r\n            center = points[0];\r\n        }\r\n\r\n        for (i = 0, dist = 0; i < len - 1; i++) {\r\n            p1 = points[i];\r\n            p2 = points[i + 1];\r\n            segDist = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\r\n            dist += segDist;\r\n\r\n            if (dist > halfDist) {\r\n                ratio = (dist - halfDist) / segDist;\r\n                center = [\r\n                    p2[0] - ratio * (p2[0] - p1[0]),\r\n                    p2[1] - ratio * (p2[1] - p1[1])\r\n                ];\r\n            }\r\n        }\r\n\r\n        return center;\r\n    }\r\n\r\n    public getExtent(): Extent {\r\n        let arr: number[][][] = this._geoCoordinates;\r\n\r\n        let xmin = Number.MAX_VALUE, ymin = Number.MAX_VALUE, xmax = -Number.MAX_VALUE, ymax = -Number.MAX_VALUE;\r\n        arr.forEach(ring => {\r\n            ring.forEach(point => {\r\n                xmin = Math.min(xmin, point[0]);\r\n                ymin = Math.min(ymin, point[1]);\r\n                xmax = Math.max(xmax, point[0]);\r\n                ymax = Math.max(ymax, point[1]);\r\n            })\r\n        });\r\n\r\n        return new Extent(ymax, ymin, xmin, xmax);\r\n    }\r\n\r\n    public contain(screenCoordinate: number[]): boolean {\r\n        let p2: number[];\r\n        const _distanceToSegment = (p: number[], p1: number[], p2: number[]) => {\r\n            let x = p1[0],\r\n                y = p1[1],\r\n                dx = p2[0] - x,\r\n                dy = p2[1] - y,\r\n                dot = dx * dx + dy * dy,\r\n                t;\r\n\r\n            if (dot > 0) {\r\n                t = ((p[0] - x) * dx + (p[1] - y) * dy) / dot;\r\n\r\n                if (t > 1) {\r\n                    x = p2[0];\r\n                    y = p2[1];\r\n                } else if (t > 0) {\r\n                    x += dx * t;\r\n                    y += dy * t;\r\n                }\r\n            }\r\n\r\n            dx = p[0] - x;\r\n            dy = p[1] - y;\r\n\r\n            return Math.sqrt(dx * dx + dy * dy);\r\n        };\r\n        return this._screenCoordinates.some(polyline => {\r\n            const distance = polyline.reduce((acc, cur) => {\r\n                if (p2) {\r\n                    const p1 = p2;\r\n                    p2 = cur;\r\n                    return Math.min(acc, _distanceToSegment(screenCoordinate, p1, p2));\r\n                } else {\r\n                    p2 = cur;\r\n                    return acc;\r\n                }\r\n            }, Number.MAX_VALUE);\r\n            return distance <= this._tolerance;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 获取线类型几何图形的长度\r\n     * from Leaflet\r\n     * @returns {number} 线总长度\r\n     */\r\n    public getLength(): number {\r\n\r\n        let sum = 0;\r\n        this._geoCoordinates.forEach((line, i) => {\r\n            line.forEach((point, j) => {\r\n                if (j > 0) {\r\n                    sum += Math.sqrt(Math.pow(point[0] - this._geoCoordinates[i][j - 1][0], 2) + Math.pow(point[1] - this._geoCoordinates[i][j - 1][0], 2));\r\n                }\r\n            })\r\n        });\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     * 求点1到点2的距离\r\n     * @param point1 点1\r\n     * @param point2 点2\r\n     * @returns {number} 点1到点2的距离\r\n     */\r\n    private calculationDistance(point1: number[], point2: number[]): number {\r\n        return Math.sqrt(Math.pow((point2[0] - point1[0]), 2) + Math.pow((point2[1] - point1[1]), 2));\r\n    }\r\n\r\n    /**\r\n     * 求A点到BC边的距离\r\n     * @param targetPoint A\r\n     * @param startPoint B\r\n     * @param endPoint C\r\n     * @returns {number} A点到BC边的距离\r\n     */\r\n    private calPointToLine(targetPoint: number[], startPoint: number[], endPoint: number[]): number {\r\n        //下面用海伦公式计算面积\r\n        let a = Math.abs(this.calculationDistance(targetPoint, startPoint));\r\n        let b = Math.abs(this.calculationDistance(targetPoint, endPoint));\r\n        let c = Math.abs(this.calculationDistance(startPoint, endPoint));\r\n        let p = (a + b + c) / 2.0;\r\n        let s = Math.sqrt(Math.abs(p * (p - a) * (p - b) * (p - c)));\r\n        return s * 2.0 / a;\r\n    }\r\n\r\n}","import { Geometry, GeometryType } from \"./Geometry\";\r\nimport { Extent } from \"../render/Extent\";\r\nimport { PointSymbol } from \"../render/symbol/PointSymbol\";\r\n\r\n/**\r\n * 点类型几何图形\r\n */\r\nexport class Point extends Geometry {\r\n    public constructor(coordinate: number[]) {\r\n        super();\r\n        this._geoCoordinates = coordinate;\r\n        this._screenCoordinates = [];\r\n        this._symbol = new PointSymbol();\r\n        this._extent = this.getExtent();\r\n        this._type = GeometryType.Point;\r\n    }\r\n\r\n    /**\r\n     * 点类型几何图形地理坐标\r\n     * @remarks 格式：[x, y]\r\n     */\r\n    private _geoCoordinates: number[];\r\n    /**\r\n     * 点类型几何图形屏幕坐标\r\n     * @remarks 通过转移矩阵计算所得\r\n     */\r\n    private _screenCoordinates: number[];\r\n    /**\r\n     * 点类型几何图形符号\r\n     */\r\n    private _symbol: PointSymbol;\r\n\r\n    /**\r\n     * 点类型几何图形包络矩形\r\n     */\r\n    public get extent(): Extent { \r\n        return this._extent; \r\n    }\r\n\r\n    public toGeoJson() {\r\n        return {\r\n            \"type\": \"Point\",\r\n            \"coordinates\": [this._geoCoordinates[0], this._geoCoordinates[1]]\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 绘制几何图像\r\n     * @param ctx Canvas画笔\r\n     * @param extent 可视区范围\r\n     * @param symbol 几何图像符号\r\n     * @returns \r\n     */\r\n    public async draw(ctx: CanvasRenderingContext2D, extent: Extent, symbol: PointSymbol): Promise<void> {\r\n        // 渲染可视区范围内的部分\r\n        if (!extent.intersect(this._extent)) return;\r\n        // 获取屏幕坐标\r\n        const matrix: DOMMatrix = ctx.getTransform();\r\n        this._screenCoordinates[0] = (matrix.a * this._geoCoordinates[0] + matrix.e);\r\n        this._screenCoordinates[1] = (matrix.d * this._geoCoordinates[1] + matrix.f);\r\n        // 获取symbol\r\n        if (symbol) this._symbol = symbol;\r\n        else this._symbol = new PointSymbol();\r\n        // 绘制\r\n        this._symbol.draw(ctx, this._screenCoordinates);\r\n    }\r\n\r\n    /**\r\n     * 获取几何图形中心点\r\n     * @returns {number[]} 中心点数组 [x, y]\r\n     */\r\n    public getCenter(): number[] {\r\n        if (this._geoCoordinates) \r\n            return [this._geoCoordinates[0], this._geoCoordinates[1]];\r\n        else \r\n            return null;\r\n    }\r\n\r\n    /**\r\n     * 获取点类型几何图形包络矩形\r\n     * @returns {Extent} 几何图形包络矩形\r\n     */\r\n    public getExtent(): Extent {\r\n        const xmax: number = this._geoCoordinates[0];\r\n        const xmin: number = this._geoCoordinates[0];\r\n        const ymax: number = this._geoCoordinates[1];\r\n        const ymin: number = this._geoCoordinates[1];\r\n        return new Extent(ymax, ymin, xmin, xmax);\r\n    }\r\n\r\n    /**\r\n     * 判断鼠标点是否在点类型几何图形范围内\r\n     * @param screenCoordinate 鼠标屏幕坐标\r\n     * @returns {boolean} \r\n     */\r\n    public contain(screenCoordinate: number[]): boolean {\r\n        if (this._symbol) \r\n            return this._symbol.contain(screenCoordinate, this._screenCoordinates)\r\n        else \r\n            return false;\r\n    }\r\n}","import { Geometry, GeometryType } from \"./Geometry\";\r\nimport { Extent } from \"../render/Extent\";\r\nimport { FillSymbol } from \"../render/symbol/FillSymbol\"\r\n\r\n/**\r\n * 面类型几何图形\r\n */\r\nexport class Polygon extends Geometry {\r\n    public constructor(coordinates: number[][][]) {\r\n        super();\r\n        this._geoCoordinates = coordinates;\r\n        this._screenCoordinates = [];\r\n        this._symbol = new FillSymbol();\r\n        this._extent = this.getExtent();\r\n        this._type = GeometryType.Polygon;\r\n    }\r\n\r\n    /**\r\n     * 面类型几何图形地理坐标\r\n     * @remarks\r\n     * 格式： [[[x11, y11], [x12, y12], ...], [[x21, y21], [x22, y22], ...], ...]\r\n     */\r\n    private _geoCoordinates: number[][][];\r\n    /**\r\n     * 面类型几何图形屏幕坐标\r\n     * @remarks 通过转移矩阵计算所得\r\n     */\r\n    private _screenCoordinates: number[][][];\r\n    /**\r\n     * 面类型几何图形符号\r\n     */\r\n    private _symbol: FillSymbol;\r\n\r\n    /**\r\n     * 面类型几何图形包络矩形\r\n     */\r\n    public get extent(): Extent {\r\n        return this._extent;\r\n    }\r\n\r\n    public toGeoJson(): any {\r\n        return {\r\n            \"type\": \"Polygon\",\r\n            \"coordinates\": this._geoCoordinates\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 绘制面类型几何图形\r\n     * @param ctx Canvas画笔\r\n     * @param extent 可视区范围\r\n     * @param symbol 几何图形符号\r\n     * @returns \r\n     */\r\n    public async draw(ctx: CanvasRenderingContext2D, extent: Extent, symbol: FillSymbol): Promise<void> {\r\n        // 只渲染可视区范围内元素\r\n        if (!extent.intersect(this._extent)) return;\r\n        const matrix: DOMMatrix = ctx.getTransform();\r\n        // 获取屏幕坐标\r\n        this._screenCoordinates = this._geoCoordinates.map(ring => {\r\n            return ring.map(point => {\r\n                return [(matrix.a * point[0] + matrix.e), (matrix.d * point[1] + matrix.f)];\r\n            });\r\n        });\r\n        // 获取Symbol\r\n        if (symbol) this._symbol = symbol;\r\n        else this._symbol = new FillSymbol();\r\n        // 绘制\r\n        this._symbol.draw(ctx, this._screenCoordinates);\r\n    }\r\n\r\n    /**\r\n     * 获取面类型几何图形中心点坐标\r\n     * @returns 中心点坐标\r\n     */\r\n    public getCenter(): number[] | null {\r\n        let i: number, j: number, p1: number[], p2: number[], f: number, area: number, x: number, y: number, center: number[],\r\n            points = this._geoCoordinates[0],\r\n            len = points.length;\r\n        if (!len) { return null; }\r\n        // polygon centroid algorithm; only uses the first ring if there are multiple\r\n        area = x = y = 0;\r\n        for (i = 0, j = len - 1; i < len; j = i++) {\r\n            p1 = points[i];\r\n            p2 = points[j];\r\n\r\n            f = p1[1] * p2[0] - p2[1] * p1[0];\r\n            x += (p1[0] + p2[0]) * f;\r\n            y += (p1[1] + p2[1]) * f;\r\n            area += f * 3;\r\n        }\r\n        if (area === 0) {\r\n            // Polygon is so small that all points are on same pixel.\r\n            center = points[0];\r\n        } else {\r\n            center = [x / area, y / area];\r\n        }\r\n        return center;\r\n    }\r\n\r\n    /**\r\n     * 获取面类型几何图形的包络矩形\r\n     * @returns 几何图形包络矩形\r\n     */\r\n    public getExtent(): Extent {\r\n        let x_arr: number[] = [], y_arr: number[] = [];\r\n        this._geoCoordinates.forEach(ring => {\r\n            ring.forEach(point => {\r\n                x_arr.push(point[0]);\r\n                y_arr.push(point[1]);\r\n            });\r\n        });\r\n        const xmax: number = Math.max(...x_arr);\r\n        const xmin: number = Math.min(...x_arr);\r\n        const ymax: number = Math.max(...y_arr);\r\n        const ymin: number = Math.min(...y_arr);\r\n        return new Extent(ymax, ymin, xmin, xmax);\r\n    }\r\n\r\n    /**\r\n     * 判断鼠标点是否在面类型几何图形范围内\r\n     * @param screenCoordinate 鼠标屏幕坐标\r\n     * @returns \r\n     */\r\n    public contain(screenCoordinate: number[]): boolean {\r\n        const first = this._screenCoordinates[0];\r\n        const others = this._screenCoordinates.slice(1);\r\n\r\n        //first ring contained && others no contained\r\n        const _pointInPolygon = (point: number[], vs: number[][]) => {\r\n            let x = point[0], y = point[1];\r\n\r\n            let inside = false;\r\n            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {\r\n                let xi = vs[i][0], yi = vs[i][1];\r\n                let xj = vs[j][0], yj = vs[j][1];\r\n\r\n                let intersect = ((yi > y) != (yj > y))\r\n                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\r\n                if (intersect)\r\n                    inside = !inside;\r\n            }\r\n\r\n            return inside;\r\n        };\r\n\r\n        return this._screenCoordinates.some(ring => _pointInPolygon(screenCoordinate, ring));\r\n    }\r\n\r\n    /**\r\n     * 获取面类型几何图形面积\r\n     * @returns 面积\r\n     */\r\n    public getArea(): number {\r\n        let sum = 0;\r\n        this._geoCoordinates.forEach((ring, index) => {\r\n            if (index == 0) {\r\n                ring.forEach((point, index) => {\r\n                    if (index > 0) {\r\n                        //梯形面积\r\n                        sum += 1 / 2 * (point[0] - ring[index - 1][0]) * (point[1] + ring[index - 1][1]);\r\n                    }\r\n                })\r\n                sum += 1 / 2 * (ring[0][0] - ring[ring.length - 1][0]) * (ring[ring.length - 1][1] + ring[0][1]);\r\n            }\r\n        });\r\n        //顺时针为正，逆时针为负\r\n        return Math.abs(sum);\r\n    }\r\n\r\n    /**\r\n     * 获取面类型几何图形的周长\r\n     * @returns 周长\r\n     */\r\n    public getPerimeter(): number {\r\n        let primeter: number = 0;\r\n        this._geoCoordinates.forEach(ring => {\r\n            ring.reduce((pre, cur) => {\r\n                primeter += this.calculationDistance(pre, cur);\r\n                return cur;\r\n            });\r\n        });\r\n        return primeter;\r\n    }\r\n\r\n    /**\r\n     * 求点1到点2的距离\r\n     * @param point1 点1\r\n     * @param point2 点2\r\n     * @returns {number} 点1到点2的距离\r\n     */\r\n    private calculationDistance(point1: number[], point2: number[]): number {\r\n        return Math.pow((point2[0] - point1[0]), 2) + Math.pow((point2[1] - point1[1]), 2);\r\n    }\r\n}","import { Extent } from \"../render/Extent\";\r\nimport { Geometry, GeometryType } from \"./Geometry\";\r\nimport { LineSymbol } from \"../render/symbol/LineSymbol\";\r\n\r\n/**\r\n * 线类型几何图形\r\n */\r\nexport class Polyline extends Geometry {\r\n    public constructor(coordinates: number[][]) {\r\n        super();\r\n        this._geoCoordinates = coordinates;\r\n        this._screenCoordinates = [];\r\n        this._symbol = new LineSymbol();\r\n        this._extent = this.getExtent();\r\n        this._type = GeometryType.Polyline;\r\n    }\r\n\r\n    /**\r\n     * 容差\r\n     * 用于鼠标交互\r\n     * 单位：pixel\r\n     */\r\n    protected static TOLERANCE: number = 4;\r\n    private _tolerance: number = 4;\r\n\r\n    /**\r\n     * 线类型几何图形地理坐标\r\n     * @remarks 格式： [[x1, y1], [x2, y2], ...]\r\n     */\r\n    private _geoCoordinates: number[][];\r\n    /**\r\n     * 线类型几何图形屏幕坐标\r\n     * @remarks 通过转移矩阵计算所得\r\n     */\r\n    private _screenCoordinates: number[][];\r\n    /**\r\n     * 线类型几何图形符号\r\n     */\r\n    private _symbol: LineSymbol;\r\n\r\n    /**\r\n     * 线类型几何图形包络矩形\r\n     */\r\n    public get extent(): Extent { \r\n        return this._extent; \r\n    }\r\n\r\n    public toGeoJson(): any {\r\n        return {\r\n            \"type\": \"LineString\",\r\n            \"coordinates\": this._geoCoordinates\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 绘制几何图像\r\n     * @param ctx Canvas画笔\r\n     * @param extent 可视区范围\r\n     * @param symbol 几何图像符号\r\n     * @returns \r\n     */\r\n    public async draw(ctx: CanvasRenderingContext2D, extent: Extent, symbol: LineSymbol): Promise<void> {\r\n        // 渲染可视区范围内的几何图像\r\n        if (!extent.intersect(this._extent)) return;\r\n        // 获得屏幕坐标\r\n        const matrix = ctx.getTransform();\r\n        this._screenCoordinates = this._geoCoordinates.map(point => {\r\n            return [(matrix.a * point[0] + matrix.e), (matrix.d * point[1] + matrix.f)];\r\n        });\r\n        // 获取Symbol\r\n        if (symbol) this._symbol = symbol;\r\n        else this._symbol = new LineSymbol();\r\n        // 绘制线类型几何图像\r\n        this._symbol.draw(ctx, this._screenCoordinates);\r\n    }\r\n\r\n    /**\r\n     * 获取线类型几何图形中心点\r\n     * @returns {number[] | null} 几何图形中心点\r\n     */\r\n    public getCenter(): number[] | null {\r\n        let i: number,\r\n            halfDist: number, \r\n            segDist: number, \r\n            dist: number, \r\n            p1: number[], \r\n            p2: number[], \r\n            ratio: number,\r\n            points = this._geoCoordinates,\r\n            len = points.length;\r\n\r\n        if (!len) { return null; }\r\n\r\n        // polyline centroid algorithm; only uses the first ring if there are multiple\r\n\r\n        for (i = 0, halfDist = 0; i < len - 1; i++) {\r\n            halfDist += Math.sqrt((points[i + 1][0] - points[i][0]) * (points[i + 1][0] - points[i][0]) + (points[i + 1][1] - points[i][1]) * (points[i + 1][1] - points[i][1])) / 2;\r\n        }\r\n\r\n        let center: number[] = [];\r\n        // The line is so small in the current view that all points are on the same pixel.\r\n        if (halfDist === 0) {\r\n            center = points[0];\r\n        }\r\n\r\n        for (i = 0, dist = 0; i < len - 1; i++) {\r\n            p1 = points[i];\r\n            p2 = points[i + 1];\r\n            segDist = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));\r\n            dist += segDist;\r\n\r\n            if (dist > halfDist) {\r\n                ratio = (dist - halfDist) / segDist;\r\n                center = [\r\n                    p2[0] - ratio * (p2[0] - p1[0]),\r\n                    p2[1] - ratio * (p2[1] - p1[1])\r\n                ];\r\n            }\r\n        }\r\n\r\n        return center;\r\n    }\r\n\r\n    /**\r\n     * 获取线类型几何图形的包络矩形\r\n     * @returns {Extent} 几何图形包络矩形\r\n     */\r\n    public getExtent(): Extent {\r\n        let x_arr: number[] = [], y_arr: number[] = [];\r\n        this._geoCoordinates.forEach(point => {\r\n            x_arr.push(point[0]);\r\n            y_arr.push(point[1]);\r\n        });\r\n        const xmax: number = Math.max(...x_arr);\r\n        const xmin: number = Math.min(...x_arr);\r\n        const ymax: number = Math.max(...y_arr);\r\n        const ymin: number = Math.min(...y_arr);\r\n        return new Extent(ymax, ymin, xmin, xmax);\r\n    }\r\n\r\n    /**\r\n     * 判断鼠标点是否在线类型几何图形符号范围之内\r\n     * @param screenCoordinate 鼠标屏幕坐标\r\n     * @returns {boolean} \r\n     */\r\n    public contain(screenCoordinate: number[]): boolean {\r\n        let p2: number[];\r\n        //from Leaflet\r\n        //点到线段的距离，垂直距离\r\n        const _distanceToSegment = (p: number[], p1: number[], p2: number[]) => {\r\n            let x = p1[0],\r\n                y = p1[1],\r\n                dx = p2[0] - x,\r\n                dy = p2[1] - y,\r\n                dot = dx * dx + dy * dy,\r\n                t;\r\n\r\n            if (dot > 0) {\r\n                t = ((p[0] - x) * dx + (p[1] - y) * dy) / dot;\r\n\r\n                if (t > 1) {\r\n                    x = p2[0];\r\n                    y = p2[1];\r\n                } else if (t > 0) {\r\n                    x += dx * t;\r\n                    y += dy * t;\r\n                }\r\n            }\r\n\r\n            dx = p[0] - x;\r\n            dy = p[1] - y;\r\n\r\n            return Math.sqrt(dx * dx + dy * dy);\r\n        }\r\n        const distance = this._screenCoordinates.reduce((acc, cur) => {\r\n            if (p2) {\r\n                const p1 = p2;\r\n                p2 = cur;\r\n                return Math.min(acc, _distanceToSegment(screenCoordinate, p1, p2));\r\n            } else {\r\n                p2 = cur;\r\n                return acc;\r\n            }\r\n        }, Number.MAX_VALUE);\r\n        return distance <= this._tolerance;\r\n    }\r\n\r\n    /**\r\n     * 获取线类型几何图形的长度\r\n     * from Leaflet\r\n     * @returns {number} 线总长度\r\n     */\r\n    public getLength(): number {\r\n        let sum = 0;\r\n        this._geoCoordinates.forEach( (point, index) => {\r\n            if (index > 0) {\r\n                sum += Math.sqrt( Math.pow(point[0] - this._geoCoordinates[index - 1][0], 2) + Math.pow(point[1] - this._geoCoordinates[index - 1][1], 2) );\r\n            }\r\n        });\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     * 求点1到点2的距离\r\n     * @param point1 点1\r\n     * @param point2 点2\r\n     * @returns {number} 点1到点2的距离\r\n     */\r\n    private calculationDistance(point1: number[], point2: number[]): number {\r\n        return Math.pow((point2[0] - point1[0]), 2) + Math.pow((point2[1] - point1[1]), 2);\r\n    }\r\n\r\n    /**\r\n     * 求A点到BC边的距离\r\n     * @param targetPoint A\r\n     * @param startPoint B\r\n     * @param endPoint C\r\n     * @returns {number} A点到BC边的距离\r\n     */\r\n    private calPointToLine(targetPoint: number[], startPoint: number[], endPoint: number[]): number {\r\n        //下面用海伦公式计算面积\r\n        let a = Math.abs(this.calculationDistance(targetPoint, startPoint));\r\n        let b = Math.abs(this.calculationDistance(targetPoint, endPoint));\r\n        let c = Math.abs(this.calculationDistance(startPoint, endPoint));\r\n        let p = (a + b + c) / 2.0;\r\n        let s = Math.sqrt(Math.abs(p * (p - a) * (p - b) * (p - c)));\r\n        return s * 2.0 / a;\r\n    }\r\n}","import { FeatureLayer } from \"../layer/FeatureLayer\";\r\nimport { Extent } from \"../render/Extent\";\r\n\r\n/**\r\n * 放大缩小几何图形\r\n * @param ctx Canvas上下文\r\n * @param target 聚焦点\r\n * @param scale 放大缩小倍数\r\n * @return {CanvasRenderingContext2D} Canvas上下文\r\n * @remarks 在ctx中存储的变换矩阵是重点\r\n */\r\nexport const scaleGeometry = (ctx: CanvasRenderingContext2D, target: {x: number, y: number}, scale: number): CanvasRenderingContext2D => {\r\n    const matrix: DOMMatrix = ctx.getTransform();\r\n    // 计算水平偏移量\r\n    const\r\n        a1 = matrix.a,\r\n        e1 = matrix.e,\r\n        x1 = target.x,\r\n        x2 = x1;\r\n    // 水平偏移量\r\n    const e = (x2 - scale * (x1 - e1) - e1) / a1;\r\n    // 计算垂直偏移量\r\n    const\r\n        d1 = matrix.d,\r\n        f1 = matrix.f,\r\n        y1 = target.y,\r\n        y2 = y1;\r\n    // 垂直偏移量\r\n    const f = (y2 - scale * (y1 - f1) - f1) / d1;\r\n    ctx.transform(scale, 0, 0, scale, e, f);\r\n    return ctx;\r\n}\r\n\r\n/**\r\n * 屏幕坐标转地理坐标\r\n * @param ctx Canvas上下文\r\n * @param coordinate 屏幕点坐标\r\n * @returns 地理点坐标\r\n */\r\n export const screenToGeo = (ctx: CanvasRenderingContext2D, coordinate: number[]): number[] => {\r\n    const matrix: DOMMatrix = ctx.getTransform();\r\n    const \r\n        x_screen: number = coordinate[0], y_screen: number = coordinate[1];\r\n    const\r\n        x_geo: number = (x_screen - matrix.e) / matrix.a,\r\n        y_geo: number = (y_screen  - matrix.f) / matrix.d;\r\n    return [x_geo, y_geo];\r\n}\r\n\r\n/**\r\n * 点击要素高亮\r\n * @param screenCoordinat 屏幕点坐标\r\n * @param extent 可视区范围\r\n * @param featureLayer 图层\r\n * @remarks Map根据是否开启identify调用该方法\r\n */\r\nexport const ClickHighlighted = (screenCoordinat: number[], extent: Extent, featureLayer: FeatureLayer): void => {\r\n    // 当identify开启，则可以使用该函数\r\n    // 遍历可视区范围内的每一个要素的Geometry，利用contain函数判断是否点击到\r\n    featureLayer.featureClass.features.forEach(feature => {\r\n        // 如果不相交，则退出\r\n        if (feature.geometry.intersect(extent)) return;\r\n        if (feature.geometry.contain(screenCoordinat)) {\r\n            // 如果点到了\r\n            feature.isHeightLighted = true;\r\n        } else {\r\n            // 如果没点到\r\n            feature.isHeightLighted = false;\r\n        }\r\n    });\r\n    // 如果点击到，启动Feature的isHignLight属性，利用高亮的symbol\r\n    // 点击其他区域，则取消这个高亮symbol，用原来的symbol重绘\r\n}\r\n\r\n/**\r\n * 清除高亮\r\n * @param featureLayer 图层\r\n */\r\nexport const ClearHighlighted = (featureLayer: FeatureLayer): void => {\r\n    featureLayer.featureClass.features.forEach(feature => {\r\n        feature.isHeightLighted = false;\r\n    });\r\n}\r\n","import { Field } from \"../render/Field\";\r\nimport { SimpleTextSymbol } from \"../render/symbol/PointSymbol\";\r\nimport { Collision, SimpleCollision } from \"./collision\";\r\nimport { Feature } from \"../element/Feature\";\r\n\r\n/**\r\n * 图层标注设置\r\n */\r\nexport class Label {\r\n\r\n    public constructor({field, symbol, collision}: any) {\r\n        this.field = field;\r\n        this.symbol = symbol ? symbol : new SimpleTextSymbol();\r\n        this.collision = collision ? collision : new SimpleCollision();\r\n    }\r\n    /**\r\n     * 标注字段\r\n     */\r\n    field: Field;\r\n    /**\r\n     * 标注符号\r\n     */\r\n    symbol: SimpleTextSymbol;\r\n    /**\r\n     * 标注冲突解决方式\r\n     */\r\n    collision: Collision;\r\n\r\n    /**\r\n     * 绘制图层标注\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    public draw(features: Feature[], ctx: CanvasRenderingContext2D) {\r\n        //通过冲突检测，得到要绘制的要素集合\r\n        const remain: Feature[] = this.collision.test(features, this.field, this.symbol, ctx);\r\n        //遍历绘制要素标注\r\n        remain.forEach((feature: Feature) => {\r\n            feature.label(this.field, ctx, this.symbol);\r\n        });\r\n    }\r\n}","import {Feature} from \"../element/Feature\";\r\nimport {SimpleTextSymbol} from \"../render/symbol/PointSymbol\";\r\nimport {Field} from \"../render/Field\";\r\nimport { Extent } from \"../render/Extent\";\r\n\r\n/**\r\n * 冲突检测基类\r\n */\r\nexport class Collision {\r\n    /**\r\n     * 冲突检测\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(features: Feature[], field: Field, symbol: SimpleTextSymbol, ctx: CanvasRenderingContext2D): Feature[] { return []; }\r\n}\r\n\r\n/**\r\n * 无检测机制\r\n */\r\nexport class NullCollision {\r\n    /**\r\n     * 冲突检测\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(features: Feature[], field: Field, symbol: SimpleTextSymbol, ctx: CanvasRenderingContext2D): Feature[] {\r\n        //没有任何检测逻辑，直接原样返回\r\n        return features;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * 简单碰撞冲突\r\n * @remarks\r\n * 类似聚合，距离判断，速度快\r\n */\r\nexport class SimpleCollision {\r\n    /**\r\n     * 检测距离\r\n     * @remarks\r\n     * 单位 pixel\r\n     */\r\n    public distance: number = 50;\r\n    /**\r\n     * 冲突检测\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(features: Feature[], field: Field, symbol: SimpleTextSymbol, ctx: CanvasRenderingContext2D): Feature[] {\r\n        //根据距离聚合\r\n        return features.reduce( (acc, cur) => {\r\n            const item: any = acc.find((item: any) => {\r\n                const distance = cur.geometry.distance(item.geometry, ctx);\r\n                return distance <= this.distance;\r\n            });\r\n            if (!item) acc.push(cur);\r\n            return acc;\r\n        }, []); // [feature]\r\n    }\r\n}\r\n\r\n/**\r\n * 叠盖碰撞冲突\r\n * @remarks\r\n * 试算标注宽高，并和已通过检测的标注，进行边界的交叉判断，速度慢\r\n */\r\nexport class CoverCollision {\r\n    /**\r\n     * 已通过检测的标注的边界集合\r\n     */\r\n    private _extents: Extent[] = [];\r\n    /**\r\n     * 判断边界碰撞时的buffer\r\n     * @remarks\r\n     * buffer越小，标注越密，单位：pixel\r\n     */\r\n    public buffer: number = 10;\r\n    /**\r\n     * 冲突检测\r\n     * @param {Feature[]} features - 准备绘制标注的要素集合\r\n     * @param {Field} field - 标注字段\r\n     * @param {SimpleTextSymbol} symbol - 标注文本符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Projection} projection - 坐标投影转换\r\n     * @return {Feature[]} 返回可绘制标注的要素集合\r\n     */\r\n    test(features: Feature[], field: Field, symbol: SimpleTextSymbol, ctx: CanvasRenderingContext2D): Feature[] {\r\n        if (!field || !symbol) return [];\r\n        this._extents = [];\r\n        const measure = (feature: Feature, symbol: SimpleTextSymbol) => {\r\n            const extent = feature.geometry.measure((feature.properties as any)[field.name], ctx, symbol);\r\n            extent.buffer(this.buffer);\r\n            if (extent) {\r\n                const item = this._extents.find( item => item.intersect(extent) );\r\n                if (!item) {\r\n                    return extent;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        const replace: any = (feature: Feature, symbol: SimpleTextSymbol, count: number) => {\r\n            const symbol2 = new SimpleTextSymbol();\r\n            symbol2.copy(symbol);\r\n            symbol2.replacement();\r\n            const bound = measure(feature, symbol2);\r\n            if (bound) {\r\n                return [bound, symbol2];\r\n            } else {\r\n                if (count == 0) {\r\n                    return [null, null];\r\n                } else {\r\n                    count -= 1;\r\n                    return replace(feature, symbol2, count);\r\n                }\r\n            }\r\n        };\r\n        //根据标注宽高的量算，得到标注的size，并和已通过检测的标注，进行边界的交叉判断，来决定是否可绘制该要素的标注\r\n        return features.reduce( (acc, cur) => {\r\n            cur.text = null;\r\n            let bound = measure(cur, symbol);\r\n            if (bound) {\r\n                acc.push(cur);\r\n                this._extents.push(bound);\r\n            } else {\r\n                if (symbol.auto) {\r\n                    const [bound, symbol2] = replace(cur, symbol, 3);    //一共4个方向，再测试剩余3个方向\r\n                    if (bound) {\r\n                        cur.text = symbol2;\r\n                        acc.push(cur);\r\n                        this._extents.push(bound);\r\n                    }\r\n                }\r\n            }\r\n            return acc;\r\n        }, []); // [feature]\r\n    }\r\n}","import { Layer } from \"./Layer\";\r\nimport { Extent } from \"../render/Extent\";\r\nimport { FeatureClass } from \"../element/FeatureClass\";\r\nimport { Renderer } from \"../render/renderer/Renderer\";\r\nimport { SimpleRenderer } from \"../render/renderer/SimpleRenderer\";\r\nimport { Feature } from \"../element/Feature\";\r\nimport { Label } from \"../label/Label\";\r\n\r\n/**\r\n * 要素图层\r\n */\r\nexport class FeatureLayer extends Layer {\r\n    public constructor(featureClass: FeatureClass, renderer: Renderer = new SimpleRenderer(featureClass.type)) {\r\n        super();\r\n        this._featureClass = featureClass;\r\n        this._renderer = renderer;\r\n        this._extent = this.getExtentFromFeature();\r\n    }\r\n\r\n    /**\r\n     * 要素集\r\n     */\r\n    private _featureClass: FeatureClass;\r\n    /**\r\n     * 图层渲染方式\r\n     */\r\n    private _renderer: Renderer;\r\n    /**\r\n     * 图层包络矩形\r\n     */\r\n    private _extent: Extent;\r\n    /**\r\n     * 图层标注设置\r\n     */\r\n    private _label: Label;\r\n    /**\r\n     * 是否显示标注\r\n     */\r\n    public labeled: boolean = false;\r\n\r\n    /**\r\n     * 图层标注设置\r\n     */\r\n    get label(): Label {\r\n        return this._label;\r\n    }\r\n    set label(value: Label) {\r\n        this._label = value;\r\n    }\r\n    /**\r\n     * 图层要素集\r\n     */\r\n    public get featureClass(): FeatureClass {\r\n        return this._featureClass;\r\n    }\r\n    public set featureClass(featureClass: FeatureClass) {\r\n        this._featureClass = featureClass;\r\n    }\r\n    /**\r\n     * 图层渲染方式\r\n     */\r\n    public get renderer(): Renderer {\r\n        return this._renderer;\r\n    }\r\n    public set renderer(renderer: Renderer) {\r\n        this._renderer = renderer;\r\n    }\r\n    /**\r\n     * 图层包络矩形\r\n     */\r\n    public get extent(): Extent {\r\n        return this._extent;\r\n    }\r\n\r\n    /**\r\n     * 通过FeatureLayer绘制\r\n     * @param ctx \r\n     * @param extent \r\n     * @returns \r\n     */\r\n    public draw(ctx: CanvasRenderingContext2D, extent: Extent, zoom: number): void {\r\n        if (!this.visible || zoom < this.minZoom || zoom > this.maxZoom) {\r\n            return;\r\n        }\r\n\r\n        // 筛选出与可视区相交的feature\r\n        const features: Feature[] = this._featureClass.features.filter(feature => feature.intersect(extent));\r\n        // 获取该渲染方式下，每一个要素对应的symbol\r\n        features.forEach(feature => {\r\n            feature.draw(ctx, extent, this.renderer.getSymbol(feature));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 绘制标注\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {Extent} extent - 当前可视范围\r\n     * @param {number} zoom - 当前缩放级别\r\n     */\r\n    public drawLabel(ctx: CanvasRenderingContext2D, extent: Extent, zoom: number) {\r\n        if (this.visible && this.minZoom <= zoom && this.maxZoom >= zoom) {\r\n            const features = this._featureClass.features.filter((feature: Feature) => feature.intersect(extent));\r\n            this._label.draw(features, ctx);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 动态获取FeatureLayer中的最大Extent\r\n     * @returns {Extent} 图层Extent\r\n     */\r\n    public getExtentFromFeature(): Extent {\r\n        const xMaxArr: number[] = [];\r\n        const xMinArr: number[] = [];\r\n        const yMaxArr: number[] = [];\r\n        const yMinArr: number[] = [];\r\n        this._featureClass.features.forEach(feature => {\r\n            xMaxArr.push(feature.geometry.getExtent().xmax);\r\n            xMinArr.push(feature.geometry.getExtent().xmin);\r\n            yMaxArr.push(feature.geometry.getExtent().ymax);\r\n            yMinArr.push(feature.geometry.getExtent().ymin);\r\n        });\r\n        return new Extent(Math.max(...yMaxArr), Math.min(...yMinArr), Math.min(...xMinArr), Math.max(...xMaxArr));\r\n    }\r\n}","import { Extent } from \"../render/Extent\";\r\n\r\n/**\r\n * 图层基类\r\n */\r\nexport class Layer {\r\n    public constructor(name: string = \"\", des: string = \"\") {\r\n        this.name = name;\r\n        this.description = des;\r\n        this.visible = true;\r\n    }\r\n    \r\n    /**\r\n     * 图层名称\r\n     */\r\n    public name: string;\r\n    /**\r\n     * 图层描述\r\n     */\r\n    public description: string;\r\n    /**\r\n     * 图层是否可见\r\n     * @remarks 控制图层是否渲染\r\n     */\r\n    public visible: boolean;\r\n\r\n    \r\n    public minZoom: number = 0;\r\n    public maxZoom: number = 10;\r\n\r\n    /**\r\n     * 对图层进行绘制\r\n     * @param ctx Canvas画笔\r\n     * @param extent 可视区范围\r\n     */\r\n    public draw(ctx: CanvasRenderingContext2D, extent: Extent, zoom: number): void {}\r\n}","import { Map } from \"../Map\";\r\nimport { Extent } from \"../render/Extent\";\r\n\r\nexport class Tiles {\r\n    public constructor({ map, extent, url, resolution }: any) {\r\n        this._map = map;\r\n        this._url = url;\r\n        this._extent = extent;\r\n        this._resolution = resolution;\r\n\r\n        //create div\r\n        this._container = document.createElement(\"div\");\r\n        this._container.style.height = this._map.container.clientHeight + \"px\";\r\n        this._container.style.width = this._map.container.clientWidth + \"px\";\r\n        this._container.style.position = \"absolute\";\r\n        this._container.style.top = this._map.container.style.top;\r\n        this._container.style.zIndex = \"-1\";\r\n        this._container.style.pointerEvents = \"none\";\r\n        this._container.style.overflow = \"hidden\";\r\n        this._container.style.userSelect = \"none\";\r\n\r\n        this._map.container.appendChild(this._container);\r\n\r\n        this._extentChange = this._extentChange.bind(this);\r\n        // this._map.on(\"extent\", this._extentChange);\r\n\r\n        window.addEventListener(\"resize\", this._onResize.bind(this));\r\n        // this.draw();\r\n    }\r\n\r\n    private _container: HTMLDivElement;\r\n    private _map: Map;\r\n    protected _url: string;\r\n    private _resolution: number[];\r\n    private _extent: Extent;\r\n\r\n    public get url(): string { return this._url; }\r\n    public set url(value: string) { this._url = value; }\r\n    public get extent() { return this._extent; }\r\n\r\n    protected _extentChange(event: any) {\r\n        this.draw();\r\n    }\r\n\r\n    public async draw(): Promise<void> {\r\n        if (!this._url) return;\r\n\r\n        this._container.innerHTML = \"\";\r\n\r\n        const extent = this._map.getViewExtent();\r\n        const zoom = this._map.zoom;\r\n\r\n        const [tileMinX, tileMinY, tileMaxX, tileMaxY] = this._geoCoord2Tile(\r\n            extent,\r\n            zoom\r\n        );\r\n        const [pixelX, pixelY] = this._geoCoord2Pixel(extent, zoom);\r\n\r\n        for (let x = tileMinX; x <= tileMaxX; x++) {\r\n            for (let y = tileMinY; y <= tileMaxY; y++) {\r\n                const url = this._getURL(this._url, y, x, zoom);\r\n                let tile = new Image(256, 256);\r\n                tile.onload = () => {\r\n                    tile.style.position = \"absolute\";\r\n                    tile.style.left = `${(x - tileMinX) * 256 + pixelX}px`;\r\n                    tile.style.top = `${(y - tileMinY) * 256 + pixelY}px`;\r\n                    this._container.appendChild(tile);\r\n                };\r\n                // tile.src = url;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _geoCoord2Tile(extent: Extent, zoom: number) {\r\n        const tileSize = 256;\r\n        const resolution = this._resolution[zoom];\r\n\r\n        const startX = Math.floor(\r\n            (extent.xmin - this._extent.xmin) / (tileSize * resolution)\r\n        );\r\n        const startY = Math.floor(\r\n            (this._extent.ymax - extent.ymax) / (tileSize * resolution)\r\n        );\r\n        const endX = Math.ceil(\r\n            (extent.xmax - this._extent.xmin) / (tileSize * resolution)\r\n        );\r\n        const endY = Math.ceil(\r\n            (this._extent.ymax - extent.ymin) / (tileSize * resolution)\r\n        );\r\n\r\n        return [startX, startY, endX, endY];\r\n    }\r\n\r\n    private _geoCoord2Pixel(extent: Extent, zoom: number) {\r\n        const tileSize = 256;\r\n        const tileResolution = this._resolution[zoom];\r\n\r\n        const pixelX = Math.floor((extent.xmin / tileResolution) / tileSize);\r\n        const pixelY = Math.floor((extent.ymax / tileResolution) / tileSize);\r\n\r\n        return [pixelX, pixelY];\r\n    }\r\n\r\n    private _getURL(baseURL: string, X: number, Y: number, Z: number): string {\r\n        return baseURL\r\n            .replace(\"{x}\", X.toString())\r\n            .replace(\"{y}\", Y.toString())\r\n            .replace(\"{z}\", Z.toString());\r\n    }\r\n\r\n    private _onResize() {\r\n        this._container.style.width = this._map.container.clientWidth + \"px\";\r\n        this._container.style.height = this._map.container.clientHeight + \"px\";\r\n        this.draw();\r\n    }\r\n}","/**\r\n * 十进制颜色\r\n */\r\nexport class Color {\r\n    public constructor(r: number, g: number, b: number, a: number = 1) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.g = g;\r\n        this.r = r;\r\n    }\r\n\r\n    /**\r\n     * Red\r\n     */\r\n    public r: number;\r\n    /**\r\n     * Green\r\n     */\r\n    public g: number;\r\n    /**\r\n     * Blue\r\n     */\r\n    public b: number;\r\n    /**\r\n     * Alpha\r\n     */\r\n    public a: number;\r\n\r\n    /**\r\n     * 输出rgba值\r\n     * @returns {string} rgba\r\n     */\r\n    public toString(): string {\r\n        return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;\r\n    }\r\n\r\n    /**\r\n     * 十六进制表示法转十进制表示法 RGB\r\n     * @param {string} hex 十六进制 \r\n     * @returns 十进制颜色\r\n     */\r\n    public static hexToRgb(hex: string): Color {\r\n        let reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/;\r\n        hex = hex.toLowerCase();\r\n        if (hex && reg.test(hex)) {\r\n            //处理三位的颜色值\r\n            if (hex.length === 4) {\r\n                var sColorNew = \"#\";\r\n                for (var i = 1; i < 4; i += 1) {\r\n                    sColorNew += hex.slice(i, i + 1).concat(hex.slice(i, i + 1));\r\n                }\r\n                hex = sColorNew;\r\n            }\r\n            //处理六位的颜色值\r\n            if (hex.length === 7) {\r\n                hex += \"ff\";\r\n            }\r\n            let sColorChange = [];\r\n            for (let i = 1; i < 9; i += 2) {\r\n                sColorChange.push(parseInt(\"0x\" + hex.slice(i, i + 2)));\r\n            }\r\n            return new Color(sColorChange[0], sColorChange[1], sColorChange[2], sColorChange[3]/255);\r\n        }\r\n        console.log(\"error Hex!\");\r\n        return new Color(0, 0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * 十进制表示法 RGB 转十六进制表示法\r\n     * @param color RGB颜色\r\n     * @returns 十六进制颜色\r\n     */\r\n    public static rgbToHex(color: Color): string {\r\n        return \"#\" + ((1 << 24) + (color.r << 16) + (color.g << 8) + color.b).toString(16).slice(1);\r\n    }\r\n\r\n    /**\r\n     * 生成随机颜色\r\n     * @returns {Color} 随机颜色\r\n     */\r\n    public static random(): Color {\r\n        return new Color(Math.random() * 255, Math.random() * 255, Math.random() * 255);\r\n    }\r\n\r\n    /**\r\n     * 获取线性色带\r\n     * @param start 起始颜色\r\n     * @param end 终止颜色\r\n     * @param count 间断数\r\n     */\r\n    public static ramp(start: Color, end: Color, count: number = 10): Color[] {\r\n        const colors: Color[] = [];\r\n        for (let i = 0; i < count; ++i) {\r\n            colors.push(new Color((end.r - start.r) * i / count + start.r, (end.g - start.g) * i / count + start.g, (end.b - start.b) * i / count + start.b, (end.a - start.a) * i / count + start.a ));\r\n        }\r\n        return colors;\r\n    }\r\n\r\n}","/**\r\n * 包络矩形\r\n * 用于空间分析，以及可视范围内渲染的判断等等\r\n * 用于参数的往往是可视区矩形\r\n * */\r\nexport class Extent {\r\n    public constructor(ymax: number, ymin: number, xmin: number, xmax: number) {\r\n        this._ymax = ymax;\r\n        this._ymin = ymin;\r\n        this._xmin = xmin;\r\n        this._xmax = xmax;\r\n        this._xscale = xmin <= xmax ? 1 : -1;\r\n        this._yscale = ymin <= ymax ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     * 四至\r\n     */\r\n    public get ymax(): number { return this._ymax; }\r\n    public get ymin(): number { return this._ymin; }\r\n    public get xmin(): number { return this._xmin; }\r\n    public get xmax(): number { return this._xmax; }\r\n    public get xscale(): number { return this._xscale; }\r\n    public get yscale(): number { return this._yscale; }\r\n\r\n    /**\r\n     * 判断两个几何图像是否相交\r\n     * @param {Extent} extent \r\n     * @returns {boolean} 是否相交\r\n     */\r\n    public intersect(extent: Extent): boolean {\r\n        if (\r\n            (extent.xmax >= this.xmin) &&\r\n            (extent.xmin <= this.xmax) &&\r\n            (extent.ymax >= this.ymin) &&\r\n            (extent.ymin <= this.ymax)\r\n        ) return true;\r\n        else return false;\r\n    }\r\n\r\n    /**\r\n     * 四至\r\n     * xscale和yscale主要用作方向的转换\r\n     *  - xscale：正一表示 X方向为自西向东，负一反之\r\n     *  - yscale：正一表示 Y方向为自北向南，负一反之\r\n     */\r\n    private _ymax: number;\r\n    private _ymin: number;\r\n    private _xmin: number;\r\n    private _xmax: number;\r\n    private _xscale: number;\r\n    private _yscale: number;\r\n\r\n    /**\r\n    * 缓冲整个边界，类似拓宽\r\n    * @param {number} size - 拓宽相应尺寸\r\n    */\r\n    public buffer(size: number) {\r\n        this._xmin -= size;\r\n        this._ymin -= size;\r\n        this._xmax += size;\r\n        this._ymax += size;\r\n    }\r\n}","export enum FieldDataType { Text, Number }\r\n\r\n/**\r\n * 字段\r\n */\r\nexport class Field {\r\n    public constructor(name: string, type: FieldDataType = FieldDataType.Text, alias: string = \"\") {\r\n        this.name = name;\r\n        this.alias = alias;\r\n        this.type = type;\r\n    }\r\n\r\n    /**\r\n     * 字段名\r\n     * @remarks 用于从Feature中找到对应的属性\r\n     */\r\n    public name: string;\r\n    /**\r\n     * 字段别称\r\n     */\r\n    public alias: string;\r\n    /**\r\n     * 字段类型\r\n     * @remarks 1. Text; 2. Number\r\n     */\r\n    public type: FieldDataType;\r\n}","import { Renderer } from \"./Renderer\";\r\nimport { Symbol } from \"../symbol/Symbol\";\r\nimport { Field } from \"../Field\";\r\nimport { FeatureClass } from \"../../element/FeatureClass\";\r\nimport { Feature } from \"../../element/Feature\";\r\n\r\nexport class CategoryRendererItem {\r\n    public constructor(value: any, symbol: Symbol, count: number = 1, label: string = value.toString()) {\r\n        this.value = value;\r\n        this.symbol = symbol;\r\n        this.count = count;\r\n        this.label = label;\r\n    }\r\n\r\n    /**\r\n     * 分类渲染该类的值\r\n     */\r\n    public value: any;\r\n    /**\r\n     * 分类渲染该类的符号\r\n     */\r\n    public symbol: Symbol;\r\n    /**\r\n     * 分类渲染该类的注记\r\n     */\r\n    public label: string;\r\n    /**\r\n     * 分类渲染该类的数量\r\n     */\r\n    public count: number;\r\n}\r\n\r\n/**\r\n * 分类渲染\r\n */\r\nexport class CategoryRenderer extends Renderer {\r\n    public constructor(field: Field, items: CategoryRendererItem[]) {\r\n        super();\r\n        this._field = field;\r\n        this._items = items;\r\n    }\r\n\r\n    /**\r\n     * 分类渲染所用字段\r\n     */\r\n    private _field: Field;\r\n    /**\r\n     * 分类渲染项\r\n     */\r\n    private _items: CategoryRendererItem[];\r\n\r\n    /**\r\n     * 分类渲染所用字段\r\n     */\r\n    public get field(): Field { \r\n        return this._field; \r\n    }\r\n    /**\r\n     * 分类渲染项\r\n     */\r\n    public get items(): CategoryRendererItem[] {\r\n        return this._items; \r\n    }\r\n\r\n    /**\r\n     * 按照指定字段在指定要素集中分类渲染\r\n     * @param featureClass 要素集\r\n     * @param field 分类字段\r\n     * @returns \r\n     */\r\n    public static generate(featureClass: FeatureClass, field: Field): CategoryRenderer {\r\n        let items: CategoryRendererItem[] = [];\r\n        let symbol: Symbol;\r\n        // 分类统计 获取items\r\n        featureClass.features.map(feature => (feature.properties as any)[field.name]).forEach(value => {\r\n            // 此处的value为properties中与field相同name的object\r\n            // 循环中遇到相同的value则count++\r\n            let item: CategoryRendererItem | undefined = items.find(item => item.value === value);\r\n            if (item) {\r\n                item.count++;\r\n            } else {\r\n                symbol = Renderer.getRandomSymbol(featureClass.type);\r\n                const item: CategoryRendererItem = new CategoryRendererItem(value, symbol);\r\n                items.push(item);\r\n            }\r\n        });\r\n        return new CategoryRenderer(field, items);\r\n    }\r\n\r\n    /**\r\n     * 分级渲染下特点属性值对应的Symbol\r\n     * @param feature 要素\r\n     */\r\n    public getSymbol(feature: Feature): Symbol {\r\n        const value: number | string = (feature.properties as any)[this._field.name];\r\n        const item: CategoryRendererItem = this._items.filter(item => {\r\n            return item.value === value\r\n        })[0];\r\n        return item.symbol;\r\n    }\r\n}","import { Renderer } from \"./Renderer\";\r\nimport { Symbol } from \"../symbol/Symbol\"\r\nimport { Field } from \"../Field\";\r\nimport { FeatureClass } from \"../../element/FeatureClass\";\r\nimport { Feature } from \"../../element/Feature\";\r\n\r\n/**\r\n * 分级渲染依赖的级结构\r\n */\r\nclass ClassRendererItem {\r\n    public constructor(low:number, hign: number, symbol: Symbol, label: string = (low + \" - \" + hign)) {\r\n        this.hign = hign;\r\n        this.low = low;\r\n        this.label = label;\r\n        this.symbol = symbol;\r\n    }\r\n    /**\r\n     * 分级渲染该级下限\r\n     */\r\n    public low: number;\r\n    /**\r\n     * 分级渲染该级上限\r\n     */\r\n    public hign: number;\r\n    /**\r\n     * 分级渲染该级符号\r\n     */\r\n    public symbol: Symbol;\r\n    /**\r\n     * 分级渲染该级题目\r\n     */\r\n    public label: string;\r\n}\r\n\r\n/**\r\n * 分级渲染\r\n */\r\nexport class ClassRenderer extends Renderer {\r\n    public constructor(field: Field, items: ClassRendererItem[]) {\r\n        super();\r\n        this._field = field;\r\n        this._items = items;\r\n    }\r\n    /**\r\n     * 分级渲染分级项集合\r\n     */\r\n    private _items: ClassRendererItem[];\r\n    /**\r\n     * 分级渲染的基础字段\r\n     * @remarks\r\n     * 要求：Number\r\n     */\r\n    private _field: Field;\r\n\r\n    /**\r\n     * 分级渲染分级项集合\r\n     */\r\n    public get item(): ClassRendererItem[] {\r\n        return this._items; \r\n    }\r\n    /**\r\n     * 分级渲染的基础字段\r\n     */\r\n    public get field(): Field { \r\n        return this._field; \r\n    }\r\n\r\n    /**\r\n     * 等间距分级渲染\r\n     * @param featureClass 要素集\r\n     * @param field 分级字段\r\n     * @param breaks 类别数\r\n     */\r\n    public static generate(featureClass: FeatureClass, field: Field, breaks: number): ClassRenderer {\r\n        const items: ClassRendererItem[] = [];\r\n        // 获取最大最小值\r\n        const stat = featureClass.features.map(feature => (feature.properties as any)[field.name]).reduce((stat, cur) => {\r\n            stat.max = Math.max(cur, stat.max);\r\n            stat.min = Math.min(cur, stat.min);\r\n        }, {min: Number.MIN_VALUE, max: Number.MAX_VALUE});\r\n        // 间隔\r\n        const interval = stat.max - stat.min;\r\n        // 放入item\r\n        for (let i = 0; i < breaks; ++i) {\r\n            const symbol: Symbol = Renderer.getRandomSymbol(featureClass.type);\r\n            const low: number = stat.min + i * interval / breaks;\r\n            const hign: number = stat.min + (i + 1) * interval / breaks;\r\n            const label: string = `${low} - ${hign}`;\r\n            const item: ClassRendererItem = new ClassRendererItem(low, hign, symbol, label);\r\n            items.push(item);\r\n        }\r\n        return new ClassRenderer(field, items);\r\n    }\r\n\r\n    /**\r\n     * 获取分级渲染下对应属性值的Symbol\r\n     * @param feature 要素\r\n     */\r\n    public getSymbol(feature: Feature): Symbol {\r\n        const value: number = (feature.properties as any)[this.field.name];\r\n        const item: ClassRendererItem = this._items.filter(item => {\r\n            if (item.hign > value && item.low < value) return true;\r\n            else return false;\r\n        })[0];\r\n        return item.symbol;\r\n    }\r\n    \r\n}","import { GeometryType } from \"../../geometry/Geometry\";\r\nimport { Color } from \"../Color\";\r\nimport { PointSymbol } from \"../symbol/PointSymbol\";\r\nimport { LineSymbol } from \"../symbol/LineSymbol\";\r\nimport { FillSymbol } from \"../symbol/FillSymbol\";\r\nimport { Symbol } from \"../symbol/Symbol\";\r\nimport { Feature } from \"../../element/Feature\";\r\n\r\n/**\r\n * 渲染方式基类\r\n */\r\nexport class Renderer {\r\n\r\n    public symbol: Symbol;\r\n    /**\r\n     * 获取随机颜色符号\r\n     * @param type 几何图形类型\r\n     * @return {Symbol} 随机颜色符号\r\n     */\r\n    public static getRandomSymbol(type: GeometryType): Symbol {\r\n        switch (type) {\r\n            case GeometryType.Point:\r\n                const symbolPoint: PointSymbol = new PointSymbol();\r\n                symbolPoint.fillStyle = Color.random().toString();\r\n                symbolPoint.strokeStyle = Color.random().toString();\r\n                return symbolPoint;\r\n            case GeometryType.MultiPoint:\r\n                const symbolMultiPoint: PointSymbol = new PointSymbol();\r\n                symbolMultiPoint.fillStyle = Color.random().toString();\r\n                symbolMultiPoint.strokeStyle = Color.random().toString();\r\n                return symbolMultiPoint;\r\n            case GeometryType.Polyline:\r\n                const symbolLine: LineSymbol = new LineSymbol();\r\n                symbolLine.strokeStyle = Color.random().toString();\r\n                return symbolLine;\r\n            case GeometryType.MultiPolyline:\r\n                const symbolMultiLine: LineSymbol = new LineSymbol();\r\n                symbolMultiLine.strokeStyle = Color.random().toString();\r\n                return symbolMultiLine;\r\n            case GeometryType.Polygon:\r\n                const symbolFill: FillSymbol = new FillSymbol();\r\n                symbolFill.fillStyle = Color.random().toString();\r\n                symbolFill.strokeStyle = Color.random().toString();\r\n                return symbolFill;\r\n            case GeometryType.MultiPolygon:\r\n                const symbolMultiFill: FillSymbol = new FillSymbol();\r\n                symbolMultiFill.fillStyle = Color.random().toString();\r\n                symbolMultiFill.strokeStyle = Color.random().toString();\r\n                return symbolMultiFill; \r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取该渲染下的Symbol（虚函数）\r\n     * @returns {Symbol} 几何图形符号\r\n     */\r\n    public getSymbol(feature: Feature): Symbol {\r\n        return new Symbol();\r\n    }\r\n}","import { Renderer } from \"./Renderer\";\r\nimport { Symbol } from \"../symbol/Symbol\";\r\nimport { GeometryType } from \"../../geometry/Geometry\";\r\nimport { Feature } from \"../../element/Feature\";\r\n\r\n/**\r\n * 单一渲染\r\n */\r\nexport class SimpleRenderer extends Renderer {\r\n    public constructor(type: GeometryType, symbol?: Symbol) {\r\n        super();\r\n        this.symbol = Renderer.getRandomSymbol(type);\r\n        this.symbol = symbol;\r\n    }\r\n\r\n    /**\r\n     * 单一渲染对应符号\r\n     */\r\n    public symbol: Symbol;\r\n\r\n    /**\r\n     * 获取单一渲染下的Symbol\r\n     * @returns \r\n     */\r\n    public getSymbol(feature: Feature): Symbol {\r\n        return this.symbol;\r\n    }\r\n}","import { Symbol } from \"./Symbol\";\r\n\r\n/**\r\n * 填充符号\r\n */\r\nexport class FillSymbol extends Symbol {\r\n    public constructor(lineWidth: number = 1, strokeStyle: string = \"ff0000\", fillStyle: string = \"#ff000088\") {\r\n        super(lineWidth, strokeStyle, fillStyle);\r\n    }\r\n\r\n    /**\r\n     * 通过Renderer调用Symbol去绘制面类型几何图像\r\n     * @param ctx Canvas上下文\r\n     * @param screenCoordinates 几何图形屏幕坐标\r\n     */\r\n    public draw(ctx: CanvasRenderingContext2D, screenCoordinates: number[][][]): void {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.resetTransform();\r\n        ctx.beginPath();\r\n        screenCoordinates.forEach(ring => {\r\n            ring.forEach((point, index) => {\r\n                if (index === 0) ctx.moveTo(point[0], point[1]);\r\n                else ctx.lineTo(point[0], point[1]);\r\n            });\r\n        });\r\n        ctx.closePath();\r\n        ctx.fill(\"evenodd\");\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}\r\n","import { Symbol } from \"./Symbol\";\r\n\r\n/**\r\n * 线状符号\r\n */\r\nexport class LineSymbol extends Symbol {\r\n    public constructor(lineWidth: number = 1, strokeStyle: string = \"ff0000\") {\r\n        super(lineWidth, strokeStyle);\r\n    }\r\n\r\n    /**\r\n     * 通过Renderer调用Symbol去绘制线类型几何图像\r\n     * @param ctx Canvas画笔\r\n     * @param screenCoordinates 屏幕坐标\r\n     */\r\n    public draw(ctx: CanvasRenderingContext2D, screenCoordinates: number[][]): void {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.resetTransform();\r\n        ctx.beginPath();\r\n        screenCoordinates.forEach((point, index) => {\r\n            if (index === 0) ctx.moveTo(point[0], point[1]);\r\n            else ctx.lineTo(point[0], point[1]);\r\n        });\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\nexport class LineDashSymbol extends LineSymbol {\r\n    public constructor(lineWidth: number = 1, strokeStyle: string = \"ff0000\") {\r\n        super(lineWidth, strokeStyle);\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D, screenCoordinates: number[][]): void {\r\n        ctx.save();\r\n  \r\n        // 绘制绿色的实线\r\n        ctx.strokeStyle = this.strokeStyle; // 设置绿色\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.resetTransform();\r\n        ctx.beginPath();\r\n        screenCoordinates.forEach((point, index) => {\r\n          if (index === 0) ctx.moveTo(point[0], point[1]);\r\n          else ctx.lineTo(point[0], point[1]);\r\n        });\r\n        ctx.stroke();\r\n        \r\n        // 绘制白色的虚线\r\n        ctx.setLineDash([5, 20]); // 设置虚线样式\r\n        ctx.strokeStyle = \"#FFFFFF\"; // 设置白色\r\n        ctx.beginPath();\r\n        screenCoordinates.forEach((point, index) => {\r\n          if (index === 0) ctx.moveTo(point[0], point[1]);\r\n          else ctx.lineTo(point[0], point[1]);\r\n        });\r\n        ctx.stroke();\r\n        \r\n        ctx.restore();\r\n    }\r\n\r\n}","import { Symbol } from \"./Symbol\";\r\n\r\n/**\r\n * 点状符号\r\n */\r\nexport class PointSymbol extends Symbol {\r\n    public constructor(lineWidth: number = 1, strokeStyle: string = \"ff0000\", fillStyle: string = \"#ff000088\", radius: number = 10) {\r\n        super(lineWidth, strokeStyle, fillStyle);\r\n        this.radius = radius;\r\n    }\r\n\r\n    /**\r\n     * 点半径\r\n     */\r\n    public radius: number;\r\n\r\n    /**\r\n     * 通过Renderer调用Symbol去绘制点类型几何图像\r\n     * @param ctx Canvas画笔\r\n     * @param coordinate 屏幕坐标\r\n     */\r\n    public draw(ctx: CanvasRenderingContext2D, coordinate: number[]): void {\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.beginPath();\r\n        // keep circle size\r\n        const matrix: DOMMatrix = ctx.getTransform();\r\n        ctx.resetTransform();\r\n        ctx.arc(coordinate[0], coordinate[1], this.radius, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * 判断点是否在符号范围内\r\n     * @param anchorCoordinate 目标点\r\n     * @param screenCoordinate 符号坐标\r\n     * @returns {boolean} 是否在范围内\r\n     */\r\n    public contain(anchorCoordinate: number[], screenCoordinate: number[]): boolean {\r\n        if (\r\n            Math.sqrt(\r\n                (anchorCoordinate[0] - screenCoordinate[0]) * (anchorCoordinate[0] - screenCoordinate[0]) + (anchorCoordinate[1] - screenCoordinate[1]) * (anchorCoordinate[1] - screenCoordinate[1])\r\n            ) <= this.radius\r\n        ) return true;\r\n        else return false;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * 图标符号\r\n * @remarks\r\n * 常用于POI兴趣点的渲染\r\n */\r\nexport class SimpleMarkerSymbol extends PointSymbol {\r\n    public constructor(url: URL, width?: number, height?: number) {\r\n        super();\r\n        this.url = url.href;\r\n        this.width = width ? width : 16;\r\n        this.height = height ? height : 16;\r\n        this.offsetX = width / -2;\r\n        this.offsetY = height / -2;\r\n    }\r\n    /**\r\n     * 宽\r\n     */\r\n    public width: number = 16;\r\n    /**\r\n     * 高\r\n     */\r\n    public height: number = 16;\r\n    /**\r\n     * offset，坐标点对应图标的位置\r\n     * 例如，宽16px，高16px，offsetX为-8，offsetY为-8，意味着：\r\n     * 该图标的中心点对应渲染点的坐标。\r\n     */\r\n    public offsetX: number = -8;\r\n    /**\r\n     * offset，坐标点对应图标的位置\r\n     * 例如，宽16px，高16px，offsetX为-8，offsetY为-8，意味着：\r\n     * 该图标的中心点对应渲染点的坐标。\r\n     */\r\n    public offsetY: number = -8;\r\n    /**\r\n     * 图标位图\r\n     */\r\n    public icon: ImageBitmap;\r\n    public image: any;\r\n    /**\r\n     * 图标url\r\n     */\r\n    public url: string;\r\n\r\n    private _loaded: boolean;\r\n    /**\r\n     * 记录是否已完成异步图标加载\r\n     */\r\n    public get loaded(): boolean {\r\n        return this._loaded;\r\n    }\r\n    /**\r\n     * 异步加载图标\r\n     * @return {Color} 生成随机色带\r\n     */\r\n    public load(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            let img = new Image();\r\n            img.onload = () => {\r\n                createImageBitmap(img).then(icon => {\r\n                    this.icon = icon;\r\n                    this._loaded = true;\r\n                    resolve(icon);\r\n                }, err => reject(err));\r\n            };\r\n            img.onerror = reject;\r\n            img.src = this.url;\r\n        })\r\n    }\r\n\r\n    /**\r\n     * 绘制图标\r\n     * @remarks 注意异步加载\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     * @param {number} screenCoordinate - 屏幕坐标\r\n     */\r\n    public draw(ctx: CanvasRenderingContext2D, screenCoordinate: number[]) {\r\n        const [screenX, screenY] = screenCoordinate;\r\n        if (!this._loaded) {\r\n            this.image = new Image();\r\n            this.image.src = this.url;\r\n            this._loaded = true;\r\n        };\r\n\r\n        ctx.save();\r\n        //const matrix = (ctx as any).getTransform();\r\n        //keep size\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        //请对应参考offset属性的描述内容\r\n        ctx.drawImage(this.icon || this.image, screenX + this.offsetX, screenY + this.offsetY, this.width, this.height);\r\n        ctx.restore();\r\n    }\r\n    /**\r\n     * 判断鼠标交互位置是否在符号范围内\r\n     **/\r\n    public contain(anchorCoordinate: number[], screenCoordinate: number[]) {\r\n        const [anchorX, anchorY] = anchorCoordinate;\r\n        const [screenX, screenY] = screenCoordinate;\r\n        return screenX >= (anchorX + this.offsetX) && screenX <= (anchorX + this.offsetX + this.width) && screenY >= (anchorY + this.offsetY) && screenY <= (anchorY + this.offsetY + this.height);\r\n    }\r\n\r\n    public static async create(url: URL, width?: number, height?: number) {\r\n        const marker = new SimpleMarkerSymbol(url, width, height);\r\n        await marker.load();\r\n        return marker;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * 字符符号\r\n * @remarks\r\n * 中英文皆可，注意控制长度，推荐单个字符\r\n */\r\nexport class LetterSymbol extends PointSymbol {\r\n    public constructor({ lineWidth, strokeStyle, fillStyle, letter, radius, fontColor, fontFamily, fontSize, fontWeight }: any) {\r\n        super(lineWidth, strokeStyle, fillStyle);\r\n        this.letter = letter ? letter : \"\";\r\n        this.radius = radius ? radius : 10;\r\n        this.fontColor = fontColor ? fontColor : \"#ff0000\";\r\n        this.fontFamily = fontFamily ? fontFamily : \"YaHei\";\r\n        this.fontSize = fontSize ? fontSize : 12;\r\n        this.fontWeight = fontWeight ? fontWeight : \"Bold\";\r\n    }\r\n    /**\r\n     * 外圈半径\r\n     */\r\n    public radius: number = 10;\r\n    /**\r\n     * 字符，中英文皆可，推荐单个字符\r\n     */\r\n    public letter: string = \"\";\r\n    /**\r\n     * 字体颜色\r\n     */\r\n    public fontColor: string = \"#ff0000\";\r\n    /**\r\n     * 字体大小\r\n     */\r\n    public fontSize: number = 12;\r\n    /**\r\n     * 字体\r\n     */\r\n    public fontFamily: string = \"YaHei\";\r\n    /**\r\n     * 字体粗细\r\n     */\r\n    public fontWeight: string = \"Bold\";\r\n\r\n    /**\r\n     * 绘制字符符号\r\n     * @param {CanvasRenderingContext2D} ctx - 绘图上下文\r\n     */\r\n    public draw(ctx: CanvasRenderingContext2D, screenCoordinate: number[]) {\r\n        const [screenX, screenY] = screenCoordinate;\r\n        ctx.save();\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.beginPath(); //Start path\r\n        //keep size\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        //绘制外圈\r\n        ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.fillStyle = this.fontColor;\r\n        ctx.font = this.fontSize + \"px/1 \" + this.fontFamily + \" \" + this.fontWeight;\r\n        //绘制字符\r\n        ctx.fillText(this.letter, screenX, screenY);\r\n        ctx.restore();\r\n    }\r\n    /**\r\n     * 判断鼠标交互位置是否在符号范围内 \r\n     **/\r\n    public contain(anchorCoordinate: number[], screenCoordinate: number[]) {\r\n        const [anchorX, anchorY] = anchorCoordinate;\r\n        const [screenX, screenY] = screenCoordinate;\r\n        return Math.sqrt((anchorX - screenX) * (anchorX - screenX) + (anchorY - screenY) * (anchorY - screenY)) <= this.radius;\r\n    }\r\n}\r\n\r\n/**\r\n * 文本符号\r\n * @remarks\r\n * 常用于文本标注\r\n */\r\nexport class SimpleTextSymbol extends Symbol {\r\n    /**\r\n     * 边框宽\r\n     */\r\n    public lineWidth: number = 3;\r\n    /**\r\n     * 边框色\r\n     */\r\n    public strokeStyle: string = \"#ff0000\"; //#ffffff\r\n    /**\r\n     * 填充色\r\n     */\r\n    public fillStyle: string = \"#ffffff\";    //#ffffff\r\n    /**\r\n     * X偏移\r\n     */\r\n    public offsetX: number = 0;\r\n    /**\r\n     * Y偏移\r\n     */\r\n    public offsetY: number = 1;\r\n    /**\r\n     * 周边留白\r\n     */\r\n    public padding: number = 5;\r\n    /**\r\n     * 字体颜色\r\n     */\r\n    public fontColor: string = \"#ff0000\";\r\n    /**\r\n     * 字体大小\r\n     */\r\n    public fontSize: number = 12;\r\n    /**\r\n     * 字体\r\n     */\r\n    public fontFamily: string = \"YaHei\";\r\n    /**\r\n     * 字体粗细\r\n     */\r\n    public fontWeight: string = \"Bold\";\r\n    /**\r\n     * 放置位置\r\n     */\r\n    public placement: string = \"BOTTOM\";   //BOTTOM TOP LEFT RIGHT\r\n    /**\r\n     * 自动调整位置\r\n     */\r\n    public auto: boolean = false;\r\n    /**\r\n     * 标注点符号的宽度\r\n     */\r\n    public pointSymbolWidth: number = 0;\r\n    /**\r\n     * 标注点符号的高度\r\n     */\r\n    public pointSymbolHeight: number = 0;\r\n\r\n    /**\r\n     * 自动调整位置\r\n     * @remarks 按逆时针方向寻找合适位置\r\n     */\r\n    replacement() {\r\n        if (this.auto) {\r\n            switch (this.placement) {\r\n                case \"BOTTOM\":\r\n                    this.placement = \"RIGHT\";\r\n                    break;\r\n                case \"RIGHT\":\r\n                    this.placement = \"TOP\";\r\n                    break;\r\n                case \"TOP\":\r\n                    this.placement = \"LEFT\";\r\n                    break;\r\n                case \"LEFT\":\r\n                    this.placement = \"BOTTOM\";\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 复制符号\r\n     */\r\n    public copy(symbol: SimpleTextSymbol) {\r\n        const copiedSymbol = this.deepCopy(symbol) as SimpleTextSymbol;\r\n        Object.assign(this, copiedSymbol);\r\n    }\r\n\r\n    private deepCopy<T>(obj: T): T {\r\n        if (typeof obj !== 'object' || obj === null) {\r\n            return obj;\r\n        }\r\n\r\n        const copy: any = Array.isArray(obj) ? [] : {};\r\n\r\n        for (const key in obj) {\r\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n                copy[key] = this.deepCopy(obj[key]);\r\n            }\r\n        }\r\n\r\n        return copy;\r\n    }\r\n\r\n}","\r\n/**\r\n * 几何图形符号\r\n */\r\nexport class Symbol {\r\n    public constructor(lineWidth: number = 1, strokeStyle: string = \"ff0000\", fillStyle: string = \"#ff000088\") {\r\n        this.lineWidth = lineWidth;\r\n        this.strokeStyle = strokeStyle;\r\n        this.fillStyle = fillStyle;\r\n    }\r\n\r\n    /**\r\n     * 线宽\r\n     */\r\n    public lineWidth: number;\r\n    /**\r\n     * 线颜色\r\n     */\r\n    public strokeStyle: string;\r\n    /**\r\n     * 填充颜色\r\n     */\r\n    public fillStyle: string;\r\n}","import { SimpleRenderer } from \"../../index\";\r\nimport { FeatureClass } from \"../element/FeatureClass\";\r\nimport { GeometryType } from \"../geometry/Geometry\";\r\nimport { FeatureLayer } from \"../layer/FeatureLayer\";\r\nimport { Renderer } from \"../render/renderer/Renderer\";\r\nimport { Loader } from \"./Loader\";\r\n\r\ninterface configURL {\r\n    url: URL,\r\n    name?: string,\r\n    type: GeometryType\r\n    description?: string,\r\n    alias?: string,\r\n    renderer?: Renderer\r\n}\r\n\r\ninterface configObj {\r\n    data: any,\r\n    name?: string,\r\n    type: GeometryType\r\n    description?: string,\r\n    alias?: string,\r\n    renderer?: Renderer\r\n}\r\n\r\n\r\nexport async function createElementByURL(obj: configURL): Promise<FeatureLayer> {\r\n    const fc = FeatureClass.fromGeoJson({\r\n        name: obj.name ? obj.name : \"\",\r\n        type: obj.type,\r\n        data: await Loader.loadGeoJson(obj.url),\r\n        alias: obj.alias ? obj.alias : \"\",\r\n        description: obj.description ? obj.description : \"\"\r\n    });\r\n    const renderer = obj.renderer ? obj.renderer : new SimpleRenderer(obj.type);\r\n    const fl = new FeatureLayer(fc, renderer);\r\n    \r\n    fl.name = obj.name;\r\n    fl.description = obj.description;\r\n    return fl;\r\n}\r\n\r\nexport async function createElementByObj(obj: configObj): Promise<FeatureLayer> {\r\n    const fc = FeatureClass.fromGeoJson({\r\n        name: obj.name ? obj.name : \"\",\r\n        type: obj.type,\r\n        data: obj.data,\r\n        alias: obj.alias ? obj.alias : \"\",\r\n        description: obj.description ? obj.description : \"\"\r\n    });\r\n    const renderer = obj.renderer ? obj.renderer : new SimpleRenderer(obj.type);\r\n    const fl = new FeatureLayer(fc, renderer);\r\n    fl.name = obj.name;\r\n    fl.description = obj.description;\r\n    return fl;\r\n}","\r\nexport class Loader {\r\n    static async loadGeoJson(path: URL | string): Promise<any> {\r\n        const response = await fetch(path, { method: \"GET\" });\r\n        const json = await response.json();\r\n        return json;\r\n    }\r\n}","export * from \"./core/Map\"\r\n\r\nexport * from \"./core/geometry/Geometry\"\r\nexport * from \"./core/geometry/Point\"\r\nexport * from \"./core/geometry/Polyline\"\r\nexport * from \"./core/geometry/Polygon\"\r\nexport * from \"./core/geometry/MultiPoint\"\r\nexport * from \"./core/geometry/MultiPolyline\"\r\nexport * from \"./core/geometry/MultiPolygon\"\r\n\r\nexport * from \"./core/layer/Tiles\"\r\nexport * from \"./core/layer/FeatureLayer\"\r\nexport * from \"./core/element/FeatureClass\"\r\n\r\nexport * from \"./core/render/Extent\"\r\nexport * from \"./core/render/Field\"\r\nexport * from \"./core/label/Label\"\r\nexport * from \"./core/utils/Loader\"\r\n\r\nexport * from \"./core/render/renderer/SimpleRenderer\"\r\nexport * from \"./core/render/renderer/ClassRenderer\"\r\nexport * from \"./core/render/renderer/CategoryRenderer\"\r\n\r\nexport * from \"./core/render/symbol/FillSymbol\"\r\nexport * from \"./core/render/symbol/LineSymbol\"\r\nexport * from \"./core/render/symbol/PointSymbol\"\r\nexport * from \"./core/label/collision\"\r\nexport * from \"./core/render/Color\"\r\n\r\nexport * from \"./core/utils/CreateElement\"","import \"./style/init.css\";\r\nimport \"./style/main.css\";\r\n\r\nimport * as loong from \"../src/index\";\r\n\r\nimport { searchPOI, populateResults, sendRequest, debounce, showDriveCarPath, remove, showBusRoad, initMap } from \"./utils\";\r\n\r\nasync function main() {\r\n    // 设置地图\r\n    const map = new loong.Map({\r\n        target: \"map\",\r\n        zoom: 3,\r\n        layers: [],\r\n        minZoom: 1,\r\n        maxZoom: 8\r\n    });\r\n\r\n    // 设置瓦片\r\n    // map.setTile(new loong.Tiles({\r\n    //     map: map,\r\n    //     extent: new loong.Extent(25813, 16029, 45293, 55077),\r\n    //     url: \"./static/tiles/{z}/{x}/{y}.png\",\r\n    //     resolution: [19.109257, 9.554629, 4.777314, 2.388657, 1.194329, 0.597164]\r\n    // }));\r\n\r\n    initMap(map);\r\n\r\n    // 获取搜索框和提示栏\r\n    const startInput = document.getElementById('start-input') as HTMLInputElement;\r\n    const endInput = document.getElementById('end-input') as HTMLInputElement;\r\n    const startResults = document.getElementById('start-results') as HTMLDivElement;\r\n    const endResults = document.getElementById('end-results') as HTMLDivElement;\r\n\r\n    // 获取按钮元素和内部圆形部分元素\r\n    const toggleButton = document.getElementById('toggleButton') as HTMLDivElement;\r\n    const toggleButtonInner = toggleButton.querySelector('.toggle-button-inner') as HTMLDivElement;\r\n    const toggleText = document.querySelector(\".toggle-button-text\") as HTMLDivElement;\r\n    const searchButton = document.getElementById('search-button') as HTMLButtonElement;\r\n\r\n    // 站点信息\r\n    const station_info = document.querySelector(\"#station_info\") as HTMLDivElement;\r\n\r\n    // 搜索框事件监听 + 防抖 -> 发送请求获得提示词\r\n    const searchPOIDebounced = debounce(searchPOI, 1000);\r\n    startInput.addEventListener('focus', function () {\r\n        if (startInput.value !== \"\") {\r\n            searchPOIDebounced(startInput.value, function (data: any) {\r\n                populateResults(startResults, data);\r\n                startResults.style.display = \"block\";\r\n            });\r\n        }\r\n    });\r\n    endInput.addEventListener('focus', function () {\r\n        if (endInput.value !== \"\") {\r\n            searchPOIDebounced(endInput.value, function (data: any) {\r\n                populateResults(endResults, data);\r\n                endResults.style.display = \"block\";\r\n            });\r\n        }\r\n    });\r\n\r\n    // 提示栏事件监听 -> 防止提示词\r\n    startResults.addEventListener(\"click\", function (e: Event) {\r\n        const optionElem = e.target as HTMLElement;\r\n        startInput.value = optionElem.innerText;\r\n    });\r\n    endResults.addEventListener(\"click\", function (e: Event) {\r\n        const optionElem = e.target as HTMLElement;\r\n        endInput.value = optionElem.innerText;\r\n    });\r\n\r\n    // 搜索框事件监听 -> 失去焦点，关闭提示栏\r\n    startInput.addEventListener(\"blur\", function (e: Event) {\r\n        setTimeout(function () {\r\n            startResults.style.display = \"none\";\r\n        }, 100);\r\n    });\r\n    endInput.addEventListener(\"blur\", function (e: Event) {\r\n        setTimeout(function () {\r\n            endResults.style.display = \"none\";\r\n        }, 100);\r\n    });\r\n\r\n    // 点击按钮时切换状态\r\n    let url = \"./search-car-road\";\r\n    toggleButton.addEventListener('click', () => {\r\n        toggleButtonInner.classList.toggle('toggle-button-on');\r\n\r\n        if (toggleButtonInner.classList.contains('toggle-button-on')) {\r\n            toggleText.textContent = '公交模式';\r\n            url = \"./search-bus-road\"\r\n        } else {\r\n            toggleText.textContent = '自驾模式';\r\n            url = \"./search-car-road\";\r\n        }\r\n\r\n    });\r\n\r\n    // 导航定位发送请求\r\n    searchButton.addEventListener(\"click\", async () => {\r\n        const startValue = startInput.value;\r\n        const endValue = endInput.value;\r\n\r\n        try {\r\n            const res = await sendRequest(url, {\r\n                start: startValue,\r\n                end: endValue\r\n            });\r\n\r\n            remove(map);\r\n            station_info.innerText = \"\";\r\n            if (url === \"./search-bus-road\") {\r\n                showBusRoad(map, res.start, res.end, res.line, res.bus_station, res.turn_line);\r\n                // 展示站点信息\r\n                let text = \"站点：\";\r\n                let line_name = \"\";\r\n                let station_name = \"\";\r\n                for (const station of res.bus_station.features) {\r\n                    if (line_name === station.properties.line_name) {\r\n                        station_name = station.properties.name;\r\n                        text += \"\\n\\t\\t'\" + station.properties.name + \"'\"\r\n                    } else {\r\n                        line_name = station.properties.line_name;\r\n                        if (station_name) text += \"\\n\\t\\t'\" + station.properties.name + \"'\"\r\n                        text += \"\\n - [\" + station.properties.line_name + \"]\\n\\t\\t'\" + station.properties.name + \"'\";\r\n                    }\r\n                }\r\n                station_info.innerText = text;\r\n                \r\n            } else {\r\n                showDriveCarPath(map, res.start, res.end, res.line);\r\n            }\r\n\r\n        } catch (err: any) {\r\n            console.error(err);\r\n        }\r\n    });\r\n};\r\n\r\nwindow.onload = main;\r\n\r\n","import axios, { AxiosResponse } from \"axios\";\r\nimport * as loong from \"../src/index\";\r\n\r\n/**\r\n * 关键字模糊查询POI\r\n * @param keyword 关键字\r\n * @param callback 回调函数callback(data)\r\n */\r\nexport function searchPOI(keyword: string, callback: Function) {\r\n    axios.get('/search-poi', {\r\n        params: {\r\n            keyword: keyword\r\n        }\r\n    })\r\n        .then(function (response) {\r\n            const data = response.data;\r\n            callback(data);\r\n        })\r\n        .catch(function (error) {\r\n            console.error(error);\r\n        });\r\n}\r\n\r\n/**\r\n * 以搜索框的下拉框的形式放置结果\r\n * @param resultsElement 放置结果的搜索框\r\n * @param data 返回的数据（数组）\r\n */\r\nexport function populateResults(resultsElement: HTMLElement, data: any) {\r\n    resultsElement.innerHTML = '';\r\n    data.forEach(function (poi: any) {\r\n        const option = document.createElement('option');\r\n        option.innerText = poi.name;\r\n        resultsElement.appendChild(option);\r\n    });\r\n}\r\n\r\n/**\r\n * 发送get请求\r\n * @param url url字符串\r\n * @param params 参数对象\r\n * @returns \r\n */\r\nexport async function sendRequest(url: string, params: any): Promise<any> {\r\n    try {\r\n        const response: AxiosResponse = await axios.get(url, { params });\r\n        return response.data;\r\n    } catch (error: any) {\r\n        // 处理请求发生的错误\r\n        throw error;\r\n    }\r\n}\r\n\r\nexport function debounce(func: Function, delay: number) {\r\n    let timer: any;\r\n    return function (...args: any[]) {\r\n        clearTimeout(timer);\r\n        timer = setTimeout(() => {\r\n            func.apply(this, args);\r\n        }, delay);\r\n    };\r\n}\r\n\r\nexport async function remove(map: loong.Map) {\r\n    if (map.getLayerByName(\"最短路径\")) {\r\n        map.removeLayerByName(\"最短路径\");\r\n    }\r\n    if (map.getLayerByName(\"起始点\")) {\r\n        map.removeLayerByName(\"起始点\");\r\n    }\r\n    if (map.getLayerByName(\"终点\")) {\r\n        map.removeLayerByName(\"终点\");\r\n    }\r\n    if (map.getLayerByName(\"公交站点\")) {\r\n        map.removeLayerByName(\"公交站点\");\r\n    }\r\n    if (map.getLayerByName(\"中转点\")) {\r\n        map.removeLayerByName(\"中转点\");\r\n    }\r\n}\r\n\r\nexport async function showDriveCarPath(map: loong.Map, start: any, end: any, line: any) {\r\n    // res 为最短路径的geojson\r\n    const road = await loong.createElementByObj({\r\n        name: \"最短路径\",\r\n        type: loong.GeometryType.Polyline,\r\n        data: line,\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Polyline,\r\n            new loong.LineDashSymbol(8, \"#45ff0d\")\r\n        )\r\n    });\r\n    map.pushLayer(road);\r\n\r\n    const startPoint = await loong.createElementByObj({\r\n        name: \"起始点\",\r\n        type: loong.GeometryType.Point,\r\n        data: start,\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Point,\r\n            // await loong.SimpleMarkerSymbol.create(\r\n            //     new URL(\"./static/marker.svg\", import.meta.url),\r\n            //     30, 30\r\n            // )\r\n            new loong.LetterSymbol({\r\n                lineWidth: 0.2,\r\n                letter: \"始\",\r\n                fontColor: \"#000000\",\r\n                strokeStyle: \"#ffca28\",\r\n                fillStyle: \"#ffca28\",\r\n                radius: 12,\r\n                fontFamily: \"楷体\",\r\n                fontSize: 12\r\n            })\r\n        )\r\n    })\r\n    map.pushLayer(startPoint);\r\n    const endPoint = await loong.createElementByObj({\r\n        name: \"终点\",\r\n        type: loong.GeometryType.Point,\r\n        data: end,\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Point,\r\n            // new loong.LetterSymbol({\r\n            //     lineWidth: 0.2,\r\n            //     letter: \"终\",\r\n            //     fontColor: \"#000000\",\r\n            //     fillStyle: \"#ffffff\",\r\n            //     radius: 15,\r\n            //     fontSize: 16,\r\n            //     fontFamily: \"微软雅黑\"\r\n            // })\r\n            await loong.SimpleMarkerSymbol.create(\r\n                new URL(\"./static/img/marker.svg\", import.meta.url),\r\n                30, 30\r\n            )\r\n        )\r\n    })\r\n    map.pushLayer(endPoint);\r\n}\r\n\r\nexport async function showBusRoad(map: loong.Map, start: any, end: any, line: any, bus_station: any, turn_line: any) {\r\n    const road = await loong.createElementByObj({\r\n        name: \"最短路径\",\r\n        type: loong.GeometryType.Polyline,\r\n        data: line,\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Polyline,\r\n            new loong.LineDashSymbol(8, \"#1677d2\")\r\n        )\r\n    });\r\n\r\n    const startPoint = await loong.createElementByObj({\r\n        name: \"起始点\",\r\n        type: loong.GeometryType.Point,\r\n        data: start,\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Point,\r\n            // await loong.SimpleMarkerSymbol.create(\r\n            //     new URL(\"./static/marker.svg\", import.meta.url),\r\n            //     30, 30\r\n            // )\r\n            new loong.LetterSymbol({\r\n                lineWidth: 0.2,\r\n                letter: \"S\",\r\n                fontColor: \"#000000\",\r\n                strokeStyle: \"#ffca28\",\r\n                fillStyle: \"#ffca28\",\r\n                radius: 12,\r\n                fontFamily: \"微软雅黑\",\r\n                fontSize: 16\r\n            })\r\n        )\r\n    });\r\n\r\n    const endPoint = await loong.createElementByObj({\r\n        name: \"终点\",\r\n        type: loong.GeometryType.Point,\r\n        data: end,\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Point,\r\n            // new loong.LetterSymbol({\r\n            //     lineWidth: 0.2,\r\n            //     letter: \"终\",\r\n            //     fontColor: \"#000000\",\r\n            //     fillStyle: \"#ffffff\",\r\n            //     radius: 15,\r\n            //     fontSize: 16,\r\n            //     fontFamily: \"微软雅黑\"\r\n            // })\r\n            await loong.SimpleMarkerSymbol.create(\r\n                new URL(\"./static/img/marker.svg\", import.meta.url),\r\n                30, 30\r\n            )\r\n        )\r\n    });\r\n\r\n    const points = await loong.createElementByObj({\r\n        type: loong.GeometryType.MultiPoint,\r\n        data: bus_station,\r\n        name: \"公交站点\",\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.MultiPoint,\r\n            new loong.PointSymbol(1, \"#000000\", \"#ffffff\", 6)\r\n        )\r\n    });\r\n\r\n    const coords = turn_line.map((p: any) => {\r\n        return [p.x, p.y];\r\n    });\r\n    const turn_point_data: any = {\r\n        type: \"FeatureColletion\",\r\n        features: [\r\n            {\r\n                type: \"Feature\",\r\n                properties: turn_line,\r\n                geometry: {\r\n                    type: \"MultiPoint\",\r\n                    coordinates: coords\r\n                }\r\n            }\r\n        ]\r\n    };\r\n\r\n    // 中转点\r\n    const turn_point = await loong.createElementByObj({\r\n        data: turn_point_data,\r\n        type: loong.GeometryType.Point,\r\n        name: \"中转点\",\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Point,\r\n            new loong.LetterSymbol({\r\n                lineWidth: 0.2,\r\n                letter: \"转\",\r\n                fontColor: \"#000000\",\r\n                strokeStyle: \"#8bc34a\",\r\n                fillStyle: \"#8bc34a\",\r\n                radius: 12,\r\n                fontFamily: \"微软雅黑\",\r\n                fontSize: 16\r\n            })\r\n        )\r\n    });\r\n\r\n    map.pushLayer(road);\r\n    map.pushLayer(points);\r\n    map.pushLayer(endPoint);\r\n    map.pushLayer(startPoint);\r\n    // map.pushLayer(turn_point);\r\n}\r\n\r\nexport async function initMap(map: loong.Map) {\r\n    // 地图加载\r\n    const road_fl = await loong.createElementByURL({\r\n        url: new URL(\"./static/map/line.geojson\", import.meta.url),\r\n        type: loong.GeometryType.Polyline,\r\n        name: \"路网数据\",\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Polyline,\r\n            new loong.LineSymbol(3, \"#ffebbe\")\r\n        )\r\n    });\r\n\r\n    const bound1_fl = await loong.createElementByURL({\r\n        url: new URL(\"./static/map/PARK2.geojson\", import.meta.url),\r\n        type: loong.GeometryType.Polygon,\r\n        name: \"边界1\",\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Polygon,\r\n            new loong.FillSymbol(0.4, \"#f0e9e2\", \"#f0e9e2\")\r\n        )\r\n    });\r\n\r\n    const bound_fl = await loong.createElementByURL({\r\n        url: new URL(\"./static/map/bound.geojson\", import.meta.url),\r\n        type: loong.GeometryType.Polygon,\r\n        name: \"边界\",\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Polygon,\r\n            new loong.FillSymbol(2, \"#d2e6bf\", \"#d2e6bf\")\r\n        )\r\n    });\r\n\r\n    const water_fl = await loong.createElementByURL({\r\n        url: new URL(\"./static/map/water.geojson\", import.meta.url),\r\n        type: loong.GeometryType.MultiPolygon,\r\n        name: \"水面\",\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.MultiPolygon,\r\n            new loong.FillSymbol(1, \"#d2e6bf\", \"#d2e6bf\")\r\n        )\r\n    });\r\n\r\n    const water1_fl = await loong.createElementByURL({\r\n        url: new URL(\"./static/map/water1.geojson\", import.meta.url),\r\n        type: loong.GeometryType.MultiPolygon,\r\n        name: \"水面\",\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.MultiPolygon,\r\n            new loong.FillSymbol(2, \"#76cff0\", \"#76cff0\")\r\n        )\r\n    });\r\n\r\n    const highway_fl = await loong.createElementByURL({\r\n        url: new URL(\"./static/map/highway.geojson\", import.meta.url),\r\n        type: loong.GeometryType.MultiPolyline,\r\n        name: \"高速公路\",\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.MultiPolyline,\r\n            new loong.LineSymbol(3, \"#c95159\")\r\n        )\r\n    });\r\n\r\n    const shq_fl = await loong.createElementByURL({\r\n        url: new URL(\"./static/map/shq.geojson\", import.meta.url),\r\n        type: loong.GeometryType.MultiPolygon,\r\n        name: \"生活区\",\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.MultiPolygon,\r\n            new loong.FillSymbol(3, \"#f1ebd6\", \"#f1ebd6\")\r\n        )\r\n    });\r\n\r\n    const jxq_fl = await loong.createElementByURL({\r\n        url: new URL(\"./static/map/studyArea.geojson\", import.meta.url),\r\n        name: \"教学区\",\r\n        type: loong.GeometryType.Polygon,\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Polygon,\r\n            new loong.FillSymbol(1, \"#cfd3da\", \"#cfd3da\")\r\n        )\r\n    });\r\n\r\n    const schoolName = await loong.createElementByURL({\r\n        url: new URL(\"./static/map/school_name.geojson\", import.meta.url),\r\n        name: \"区域\",\r\n        type: loong.GeometryType.Polygon,\r\n        renderer: new loong.SimpleRenderer(\r\n            loong.GeometryType.Polygon,\r\n            new loong.FillSymbol(0.1, \"rgba(255, 255, 255, 0)\", \"rgba(255, 255, 255, 0)\")\r\n        )\r\n    });\r\n\r\n    schoolName.labeled = true;\r\n    const symbol = new loong.SimpleTextSymbol();\r\n    symbol.auto = true;\r\n    symbol.strokeStyle = \"rgba(255, 0, 0, 0)\";\r\n    symbol.fillStyle = \"rgba(255, 0, 0, 0)\";\r\n    symbol.fontColor = \"#000000\";\r\n    symbol.fontSize = 15;\r\n    schoolName.label = new loong.Label({\r\n        field: new loong.Field(\"name\"),\r\n        collision: new loong.SimpleCollision(),\r\n        symbol: symbol\r\n    });\r\n\r\n    road_fl.minZoom = 2;\r\n    highway_fl.minZoom = 2;\r\n    bound1_fl.minZoom = 2;\r\n    shq_fl.minZoom = 3;\r\n    jxq_fl.minZoom = 2;\r\n\r\n    map.pushLayer(bound1_fl);\r\n    map.pushLayer(bound_fl);\r\n    map.pushLayer(water_fl);\r\n    map.pushLayer(water1_fl);\r\n    map.pushLayer(shq_fl);\r\n    map.pushLayer(jxq_fl);\r\n    map.pushLayer(highway_fl);\r\n    map.pushLayer(schoolName);\r\n    map.pushLayer(road_fl);\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl + \"../\";","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunknavigation_gz\"] = self[\"webpackChunknavigation_gz\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_axios_lib_axios_js\"], () => (__webpack_require__(\"./view/main.ts\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}